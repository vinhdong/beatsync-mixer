<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>BeatSync Mixer</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #000;
      color: white;
      padding-top: 120px; /* Space for Spotify player */
      overflow-x: hidden; /* Prevent horizontal scroll */
    }

    /* Spotify Web Player - Fixed at top */
    #spotify-player-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: linear-gradient(90deg, #121212 0%, #282828 100%);
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      border-bottom: 1px solid #333;
      backdrop-filter: blur(10px); /* Add blur effect for better separation */
    }

    #full-player {
      width: 100%;
      height: 100%;
      padding: 0 20px;
    }

    .player-content {
      display: flex;
      align-items: center;
      height: 100%;
      max-width: 1200px;
      margin: 0 auto;
      gap: 20px;
    }

    .track-info {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
      min-width: 0;
    }

    .track-details {
      min-width: 0;
      flex: 1;
    }

    .track-name {
      font-size: 14px;
      font-weight: 600;
      color: white;
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .track-artist {
      font-size: 12px;
      color: #b3b3b3;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .player-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-btn {
      background: none;
      border: none;
      color: #b3b3b3;
      font-size: 16px;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: all 0.2s;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-btn:hover:not(:disabled) {
      color: white;
      background-color: rgba(255,255,255,0.1);
    }

    .control-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .play-btn {
      background-color: white !important;
      color: black !important;
      font-size: 14px;
      width: 32px;
      height: 32px;
    }

    .play-btn:hover:not(:disabled) {
      background-color: #f0f0f0 !important;
      transform: scale(1.05);
    }

    .progress-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      flex: 1;
      max-width: 200px;
    }

    .progress-bar-container {
      width: 100%;
      height: 4px;
      background: #4f4f4f;
      border-radius: 2px;
      cursor: pointer;
      position: relative;
    }

    .progress-bar {
      width: 100%;
      height: 100%;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: #1db954;
      border-radius: 2px;
      width: 0%;
      transition: width 0.1s;
    }

    .time-info {
      font-size: 11px;
      color: #b3b3b3;
      white-space: nowrap;
    }

    .volume-section {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 120px;
    }

    .volume-icon {
      color: #b3b3b3;
      font-size: 14px;
    }

    .volume-slider {
      width: 80px;
      height: 4px;
      background: #4f4f4f;
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
    }

    .status {
      font-size: 11px;
      color: #b3b3b3;
      min-width: 100px;
      text-align: right;
    }

    /* Loading spinner */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid #333;
      border-radius: 50%;
      border-top-color: #1db954;
      animation: spin 1s ease-in-out infinite;
      margin-right: 10px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Main content area */
    .main-content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
      min-height: calc(100vh - 120px);
      border-radius: 8px 8px 0 0;
      position: relative;
      z-index: 1; /* Ensure content stays below fixed player */
    }

    h1 {
      color: #1db954;
      text-align: center;
      margin-bottom: 30px;
    }

    /* Header with restart button */
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      position: relative;
      z-index: 10; /* Ensure header is above other content */
    }

    h2 {
      color: #333;
      border-bottom: 2px solid #1db954;
      padding-bottom: 10px;
    }

    #login {
      text-align: center;
      margin: 40px 0;
    }

    #login a {
      display: inline-block;
      background-color: #1db954;
      color: white;
      padding: 12px 24px;
      text-decoration: none;
      border-radius: 50px;
      font-weight: bold;
      transition: background-color 0.3s;
    }

    #login a:hover {
      background-color: #1ed760;
    }

    ul {
      list-style: none;
      padding: 0;
    }

    li {
      background: white;
      margin: 10px 0;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #333;
    }

    li:hover {
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    button {
      background-color: #1db954;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #1ed760;
    }

    #back-btn {
      background-color: #666;
      margin-bottom: 15px;
    }

    #back-btn:hover {
      background-color: #777;
    }

    /* Side by side layout for playlists and queue */
    .content-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }

    .section {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      color: #333;
    }

    /* Floating Chat Box */
    #floating-chat {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 320px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      z-index: 999;
      transition: all 0.3s ease;
      border: 1px solid #ddd;
    }

    #floating-chat.minimized {
      height: 50px;
      overflow: hidden;
    }

    #chat-header {
      background: #1db954;
      color: white;
      padding: 12px 16px;
      border-radius: 12px 12px 0 0;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }

    #chat-toggle {
      background: none;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #chat-content {
      height: 300px;
      display: flex;
      flex-direction: column;
      color: #333;
    }

    #chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      background: #f9f9f9;
      border-bottom: 1px solid #eee;
    }

    .chat-message {
      margin-bottom: 8px;
      padding: 6px 8px;
      border-radius: 4px;
      background: white;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      font-size: 13px;
    }

    .chat-user {
      font-weight: bold;
      color: #1db954;
      font-size: 12px;
    }

    .chat-time {
      font-size: 10px;
      color: #666;
      float: right;
    }

    #chat-form {
      padding: 12px;
      display: flex;
      gap: 8px;
      background: white;
      border-radius: 0 0 12px 12px;
    }

    #chat-input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 20px;
      font-size: 13px;
      outline: none;
    }

    #chat-form button {
      padding: 8px 16px;
      font-size: 12px;
      border-radius: 20px;
    }
    .vote-buttons {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 5px;
    }
    .vote-btn {
      background: none;
      border: none;
      font-size: 1.2em;
      cursor: pointer;
      padding: 5px;
      border-radius: 3px;
      transition: all 0.2s ease;
      position: relative;
    }
    .vote-btn:hover {
      background-color: #f0f0f0;
      transform: scale(1.1);
    }
    .vote-btn:active {
      transform: scale(0.9);
    }
    .vote-btn.just-voted {
      animation: buttonPulse 0.3s ease-out;
    }
    
    @keyframes buttonPulse {
      0% {
        transform: scale(1);
        background-color: transparent;
      }
      50% {
        transform: scale(1.2);
        background-color: rgba(29, 185, 84, 0.3);
      }
      100% {
        transform: scale(1);
        background-color: #f0f0f0;
      }
    }
    .vote-count {
      font-size: 0.9em;
      color: #666;
    }
    .recommendations-btn {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 0.8em;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-left: 10px;
    }
    .recommendations-btn:hover {
      background-color: #2980b9;
    }
    .recommendations-list {
      margin-top: 10px;
      padding: 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
      border-left: 3px solid #3498db;
      display: none;
    }
    .recommendations-list.visible {
      display: block;
    }
    .recommendation-item {
      padding: 5px 0;
      border-bottom: 1px solid #dee2e6;
    }
    .recommendation-item:last-child {
      border-bottom: none;
    }
    .recommendation-link {
      color: #3498db;
      text-decoration: none;
      font-weight: 500;
    }
    .recommendation-link:hover {
      text-decoration: underline;
    }
    #playback-section {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      text-align: center;
    }
    #play-btn {
      background-color: #1db954;
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 50px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    #play-btn:hover {
      background-color: #1ed760;
    }
    #play-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    /* Playback control styles */
    #playback-controls button {
      background-color: #1db954;
      border: none;
      color: white;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #playback-controls button:hover:not(:disabled) {
      background-color: #1ed760;
      transform: scale(1.05);
    }
    #playback-controls button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    #play-pause-btn {
      width: 55px !important;
      height: 55px !important;
    }
    #volume-control input[type="range"] {
      -webkit-appearance: none;
      height: 5px;
      border-radius: 5px;
      background: #ddd;
      outline: none;
    }
    #volume-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #1db954;
      cursor: pointer;
    }
    #now-playing {
      border-left: 4px solid #1db954;
    }
    .next-to-play {
      border-left: 4px solid #1db954 !important;
      background: linear-gradient(90deg, rgba(29, 185, 84, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%) !important;
    }
    .next-to-play::before {
      content: "‚ñ∂Ô∏è NEXT";
      position: absolute;
      top: 8px;
      right: 8px;
      background: #1db954;
      color: white;
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 10px;
      font-weight: bold;
    }
    .queue-item {
      position: relative;
      transition: all 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
      transform: translateY(0);
    }
    
    .queue-item.moving-up {
      animation: slideUp 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    
    .queue-item.moving-down {
      animation: slideDown 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    
    @keyframes slideUp {
      0% {
        transform: translateY(0);
        background-color: rgba(29, 185, 84, 0.1);
      }
      50% {
        transform: translateY(-10px);
        background-color: rgba(29, 185, 84, 0.3);
        box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
      }
      100% {
        transform: translateY(0);
        background-color: transparent;
      }
    }
    
    @keyframes slideDown {
      0% {
        transform: translateY(0);
        background-color: rgba(255, 165, 0, 0.1);
      }
      50% {
        transform: translateY(10px);
        background-color: rgba(255, 165, 0, 0.3);
        box-shadow: 0 4px 12px rgba(255, 165, 0, 0.3);
      }
      100% {
        transform: translateY(0);
        background-color: transparent;
      }
    }
    
    .queue-item.highlight-new-vote {
      animation: pulseVote 0.4s ease-in-out;
    }
    
    @keyframes pulseVote {
      0% {
        transform: scale(1);
        background-color: transparent;
      }
      50% {
        transform: scale(1.02);
        background-color: rgba(29, 185, 84, 0.2);
      }
      100% {
        transform: scale(1);
        background-color: transparent;
      }
    }
    .role-indicator {
      background-color: #1db954;
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8em;
      font-weight: bold;
    }
    
    #host-restart-btn {
      background-color: #e74c3c !important;
      color: white !important;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      font-weight: bold;
      transition: all 0.3s ease;
      position: relative;
      z-index: 100; /* Ensure button is always visible */
      min-width: 120px;
    }
    
    #host-restart-btn:hover {
      background-color: #c0392b !important;
      transform: scale(1.05);    }
    
    /* Role Selection Styles */
    .role-selection {
      text-align: center;
      max-width: 600px;
      margin: 0 auto;
      padding: 40px 20px;
    }
    
    .role-selection h2 {
      color: white;
      margin-bottom: 30px;
      font-size: 1.5em;
    }
    
    .role-options {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .role-option {
      flex: 1;
      min-width: 160px;
      max-width: 200px;
    }
    
    .role-btn {
      display: block;
      padding: 20px 15px;
      border-radius: 12px;
      text-decoration: none;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: inherit;
      font-size: 1em;
      width: 100%;
      position: relative;
      overflow: hidden;
    }
    
    .role-btn small {
      display: block;
      font-size: 0.8em;
      margin-top: 8px;
      opacity: 0.9;
    }
    
    .host-btn {
      background: linear-gradient(135deg, #1db954 0%, #1ed760 100%);
      color: white;
    }
    
    .listener-btn {
      background: linear-gradient(135deg, #2196F3 0%, #21CBF3 100%);
      color: white;
    }
    
    .guest-btn {
      background: linear-gradient(135deg, #9C27B0 0%, #E91E63 100%);
      color: white;
    }
    
    .role-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }
    
    .host-btn:hover {
      background: linear-gradient(135deg, #1ed760 0%, #1db954 100%);
    }
    
    .listener-btn:hover {
      background: linear-gradient(135deg, #21CBF3 0%, #2196F3 100%);
    }
    
    .guest-btn:hover {
      background: linear-gradient(135deg, #E91E63 0%, #9C27B0 100%);
    }
    
    @media (max-width: 768px) {
      .role-options {
        flex-direction: column;
        align-items: center;
      }
      
      .role-option {
        width: 100%;
        max-width: 280px;
      }
    }

    @media (max-width: 768px) {
      .container {
        grid-template-columns: 1fr;
      }
      
      .main-content > div:first-child {
        flex-direction: column;
        gap: 10px;
      }
      
      #host-restart-btn {
        font-size: 0.8em;
        padding: 6px 12px;
      }
    }
  </style>
  <!-- Spotify Web Playback SDK -->
  <script src="https://sdk.scdn.co/spotify-player.js"></script>
</head>
<body>
  <!-- Spotify Web Player - Fixed at top -->
  <div id="spotify-player-container">
    <div id="spotify-embed-wrapper" style="display: none;">
      <iframe id="spotify-player" 
              style="border-radius:12px" 
              src="" 
              width="100%" 
              height="152" 
              frameBorder="0" 
              allowfullscreen="" 
              allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
              loading="lazy">
      </iframe>
    </div>
    <div id="full-player">
      <div class="player-content">
        <div class="track-info">
          <div id="album-art">
            <img id="album-image" src="" alt="Album Art" style="width: 60px; height: 60px; border-radius: 4px; display: none;">
            <div id="no-track-placeholder" style="width: 60px; height: 60px; background: #333; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #666;">‚ô™</div>
          </div>
          <div class="track-details">
            <div class="track-name" id="current-track-name">No track playing</div>
            <div class="track-artist" id="current-track-artist">Connect to start playback</div>
          </div>
        </div>
        
        <div class="player-controls">
          <button class="control-btn" id="prev-btn" onclick="previousTrack()" disabled>‚èÆÔ∏è</button>
          <button class="control-btn play-btn" id="play-pause-btn" onclick="togglePlayback()" disabled>‚ñ∂Ô∏è</button>
          <button class="control-btn" id="next-btn" onclick="nextTrack()" disabled>‚è≠Ô∏è</button>
        </div>
        
        <div class="progress-section">
          <div class="progress-bar-container" onclick="seekToPosition(event)">
            <div class="progress-bar" id="progress-bar">
              <div class="progress-fill" id="progress-fill"></div>
            </div>
          </div>
          <div class="time-info">
            <span id="current-time">0:00</span> / <span id="total-time">0:00</span>
          </div>
        </div>
        
        <div class="volume-section">
          <span class="volume-icon">üîä</span>
          <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="50" onchange="setVolume(this.value)">
        </div>
        
        <div class="status" id="connection-status">üî¥ Disconnected</div>
      </div>
    </div>
  </div>

  <!-- Main content area -->
  <div class="main-content">
    <div class="header-container">
      <h1>üéµ BeatSync Mixer</h1>
      <div style="display: flex; gap: 10px; align-items: center;">
        <button id="logout-btn" onclick="window.location.href='/logout'" style="
          background-color: #1db954; 
          color: white; 
          border: none; 
          padding: 8px 16px; 
          border-radius: 4px; 
          cursor: pointer; 
          font-size: 0.9em; 
          font-weight: bold;
          transition: all 0.3s ease;
        " onmouseover="this.style.backgroundColor='#1ed760'" onmouseout="this.style.backgroundColor='#1db954'">
          üîÑ Switch Role
        </button>
        <button id="host-restart-btn" onclick="restartSession()">
          üîÑ Restart Session
        </button>
      </div>
    </div>

    <div id="login" style="display: none;">
      <div class="role-selection">
        <h2>Choose how to join BeatSync Mixer</h2>
        <div class="role-options">
          <div class="role-option">
            <a href="/login?role=host" class="role-btn host-btn">
              üéµ Host Session
              <small>Control music, manage playlists</small>
            </a>
          </div>
          <div class="role-option">
            <a href="/join-listener" class="role-btn listener-btn">
              üéß Join as Listener
              <small>No Spotify account required - join instantly!</small>
            </a>
          </div>
          <div class="role-option">
            <button onclick="continueAsGuest()" class="role-btn guest-btn">
              üëã Continue as Guest
              <small>Vote, chat, browse - no login required</small>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Side-by-side content grid -->
    <div class="content-grid">
      <!-- Left side: Playlists and Tracks -->
      <div class="section">
        <div id="playlists" style="display:block;">
          <h2>Your Playlists</h2>
          <ul id="playlist-list"></ul>
        </div>

        <div id="tracks" style="display:none;">
          <button id="back-btn" style="margin-bottom:10px;">‚Üê Back to Playlists</button>
          <h2>Playlist Tracks</h2>
          <ul id="track-list"></ul>
        </div>
      </div>

      <!-- Right side: Queue -->
      <div class="section">
        <div id="queue-section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2>Current Queue <small style="font-size: 0.6em; color: #666; font-weight: normal;">(ordered by votes)</small></h2>
            <button id="clear-queue-btn" onclick="clearQueue()" style="background-color: #e74c3c;">Clear Queue</button>
          </div>
          <ul id="queue"></ul>
          <div id="queue-empty" style="display: none; text-align: center; color: #666; padding: 20px;">
            No tracks in queue. Add some music! üéµ
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Floating Chat Box -->
  <div id="floating-chat">
    <div id="chat-header" onclick="toggleChat()">
      <span>üí¨ Chat</span>
      <button id="chat-toggle">‚àí</button>
    </div>
    <div id="chat-content">
      <div id="chat-messages"></div>
      <form id="chat-form" onsubmit="sendChatMessage(event)">
        <input type="text" id="chat-input" placeholder="Type a message..." maxlength="200">
        <button type="submit">Send</button>
      </form>
    </div>
  </div>

  <!-- TODO: Add voting system for queue items -->
  <!-- TODO: Add chat functionality -->
  <!-- TODO: Integrate Spotify Web Playback SDK for playback control -->

  <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
  <script>
    // Immediate role initialization - run before any other code
    (function() {
      // Check if user role is injected from server
      const role = window.userRole;
      const loginDiv = document.getElementById('login');
      
      console.log('Immediate initialization - Role:', role, 'Login div exists:', !!loginDiv);
      
      // If no role is defined or it's undefined, this means we weren't properly authenticated
      if (!role || role === 'undefined' || role === '' || role === 'null') {
        console.log('No valid role found, checking if we should redirect');
        
        // If we're on the main page but have no role, redirect to role selection
        if (window.location.pathname === '/' || window.location.pathname === '/index.html') {
          console.log('On main page but no valid role, redirecting to role selection');
          window.location.href = '/select-role?error=session_lost';
          return;
        }
        
        // Otherwise, show login interface
        if (loginDiv) {
          loginDiv.style.display = 'block';
          loginDiv.style.visibility = 'visible';
          console.log('Login div shown for unauthenticated user');
        }
        
      } else if (role && role !== 'guest' && loginDiv) {
        // Hide login for authenticated users immediately
        loginDiv.style.display = 'none';
        loginDiv.style.visibility = 'hidden';
        console.log('Login div hidden for authenticated user with role:', role);
      } else if (!role && loginDiv) {
        // Show login for unauthenticated users
        loginDiv.style.display = 'block';
        loginDiv.style.visibility = 'visible';
        console.log('Login div shown for unauthenticated user');
      }
    })();

    const socket = io();
    let queueCount = 0;
    let currentUser = 'User_' + Math.random().toString(36).substr(2, 9); // Generate random user ID
    let voteData = {}; // Store vote counts for tracks
    let socketConnected = false; // Track socket connection status

    // Socket connection events
    socket.on('connect', function() {
      console.log('Socket.IO connected');
      socketConnected = true;
    });

    socket.on('disconnect', function() {
      console.log('Socket.IO disconnected');
      socketConnected = false;
    });

    socket.on('error', function(error) {
      console.error('Socket.IO error:', error);
      
      // Show user-friendly error message
      if (error.message) {
        alert('Error: ' + error.message);
      }
      
      // If authentication error, fetch session info for debugging
      if (error.message && error.message.includes('Authentication')) {
        fetch('/session-info')
          .then(response => response.json())
          .then(sessionData => {
            console.log('Session data after auth error:', sessionData);
          })
          .catch(err => console.error('Failed to fetch session info after error:', err));
      }
    });

    // Playback state events from host
    socket.on("playback_started", data => {
      console.log('Playback started:', data);
      
      // Update UI to show something is playing
      if (data.track_uri) {
        // Find the track in the queue and highlight it as playing
        const trackElements = document.querySelectorAll(`li[data-track-uri="${data.track_uri}"]`);
        trackElements.forEach(el => {
          el.style.background = 'rgba(29, 185, 84, 0.2)';
          el.style.border = '2px solid #1db954';
          
          // Add playing indicator
          const playingIndicator = el.querySelector('.playing-indicator');
          if (!playingIndicator) {
            const indicator = document.createElement('span');
            indicator.className = 'playing-indicator';
            indicator.innerHTML = ' üéµ Playing';
            indicator.style.color = '#1db954';
            indicator.style.fontWeight = 'bold';
            el.appendChild(indicator);
          }
        });
      }
      
      // Show notification for listeners
      if (window.userRole === 'listener') {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #1db954;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          z-index: 1000;
          font-weight: bold;
        `;
        notification.textContent = 'üéµ Host started playing music';
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      }
    });

    socket.on("playback_paused", data => {
      console.log('Playback paused:', data);
      
      // Remove playing indicators from all tracks
      const playingIndicators = document.querySelectorAll('.playing-indicator');
      playingIndicators.forEach(indicator => indicator.remove());
      
      // Remove highlight from all tracks
      const trackElements = document.querySelectorAll('li[data-track-uri]');
      trackElements.forEach(el => {
        el.style.background = '';
        el.style.border = '';
      });
      
      // Show notification for listeners
      if (window.userRole === 'listener') {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #666;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          z-index: 1000;
          font-weight: bold;
        `;
        notification.textContent = '‚è∏Ô∏è Host paused the music';
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      }
    });

    // Playlists became available from host
    socket.on("playlists_available", data => {
      console.log('Playlists available from host:', data);
      
      // Show notification for listeners
      if (window.userRole === 'listener') {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #1db954;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          z-index: 1000;
          font-weight: bold;
        `;
        notification.textContent = `üéµ ${data.host_name} shared ${data.playlist_count} playlists!`;
        document.body.appendChild(notification);
        
        // Auto-reload playlists for listeners
        setTimeout(() => {
          loadPlaylists();
        }, 1000);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 5000);
      }
    });

    // Spotify Web Playback SDK variables
    let player = null;
    let deviceId = null;
    let currentTrack = null;
    let isPlaying = false;
    let accessToken = null;
    let currentTrackUri = null;
    let currentPosition = 0;
    let duration = 0;
    let progressInterval = null;

    // Track end detection using progress tracking
    let trackEndCheckInterval = null;

    // Continue as guest function
    function continueAsGuest() {
      // Hide the login section
      const loginDiv = document.getElementById('login');
      if (loginDiv) {
        loginDiv.style.display = 'none';
      }
      
      // Set role to guest and initialize UI
      window.userRole = 'guest';
      window.userId = 'guest_' + Math.random().toString(36).substr(2, 9);
      window.displayName = 'Guest';
      
      console.log('Continuing as guest:', window.userId);
      
      // Initialize guest UI
      initializeRoleBasedUI();
      
      // Load only shared data for guests (no playlists since they don't have Spotify auth)
      loadQueue();
      
      // Socket.IO will automatically connect when the page loads
      console.log('Guest setup complete');
    }

    // Initialize Spotify Web Playback SDK
    window.onSpotifyWebPlaybackSDKReady = () => {
      initializeSpotifyPlayer();
    };

    async function initializeSpotifyPlayer() {
      // Only initialize Spotify Player for hosts
      if (window.userRole !== 'host') {
        console.log('Skipping Spotify Player initialization - user is not host');
        return;
      }
      
      try {
        // Get access token from backend
        const tokenResponse = await fetch('/playback/spotify-token', {
          credentials: 'include'
        });
        if (!tokenResponse.ok) {
          console.log('Failed to get Spotify token, status:', tokenResponse.status);
          updateConnectionStatus('üî¥ Not authenticated');
          console.log('User not authenticated with Spotify');
          return;
        }
        
        const tokenData = await tokenResponse.json();
        accessToken = tokenData.access_token;
        console.log('Successfully retrieved access token for Spotify Player:', accessToken ? 'Token present' : 'No token');

        // Initialize the Spotify Player
        player = new Spotify.Player({
          name: 'BeatSync Mixer Player',
          getOAuthToken: cb => { cb(accessToken); },
          volume: 0.5
        });

        // Error handling
        player.addListener('initialization_error', ({ message }) => {
          console.error('Spotify Player initialization error:', message);
          updateConnectionStatus('üî¥ Initialization error');
          if (message.includes('Spotify Premium')) {
            alert('Spotify Premium is required for web playback. Please upgrade your account to use the music player.');
          }
        });

        player.addListener('authentication_error', ({ message }) => {
          console.error('Spotify Player authentication error:', message);
          console.error('This usually means missing scopes or invalid token');
          updateConnectionStatus('üî¥ Authentication error');
          // Only show popup for hosts, and make it less intrusive
          if (window.userRole === 'host') {
            console.log('Authentication error for host - checking token and scopes');
            // Check what token we have
            fetch('/playback/spotify-token', { credentials: 'include' })
              .then(r => r.json())
              .then(data => console.log('Current token data:', data))
              .catch(e => console.error('Failed to get token info:', e));
            
            // Show a less intrusive notification instead of alert
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
              position: fixed; top: 120px; right: 20px; 
              background: #f44336; color: white; padding: 15px; 
              border-radius: 8px; z-index: 1001; max-width: 300px;
              box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            `;
            errorDiv.innerHTML = `
              <strong>‚ö†Ô∏è Spotify Player Authentication Issue</strong><br>
              <small>Error: ${message}<br>You may need to re-authenticate to get proper permissions for music playback.</small>
              <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 16px; cursor: pointer; margin-left: 10px;">√ó</button>
            `;
            document.body.appendChild(errorDiv);
            // Auto-remove after 15 seconds
            setTimeout(() => {
              if (errorDiv.parentElement) errorDiv.remove();
            }, 15000);
          }
        });

        player.addListener('account_error', ({ message }) => {
          console.error('Spotify Player account error:', message);
          updateConnectionStatus('üî¥ Premium required');
          alert('Spotify Premium is required for web playback. Please upgrade your account.');
        });

        player.addListener('playback_error', ({ message }) => {
          console.error('Spotify Player playback error:', message);
          alert('Playback error: ' + message);
        });

        // Ready
        player.addListener('ready', ({ device_id }) => {
          console.log('Ready with Device ID', device_id);
          deviceId = device_id;
          updateConnectionStatus('üü¢ Connected');
          enablePlaybackControls(true);
          
          // Transfer playback to this device
          transferPlaybackToDevice(device_id);
        });

        // Not Ready
        player.addListener('not_ready', ({ device_id }) => {
          console.log('Device ID has gone offline', device_id);
          updateConnectionStatus('üî¥ Disconnected');
          enablePlaybackControls(false);
        });

        // Player state changed
        player.addListener('player_state_changed', (state) => {
          if (!state) return;

          const previousTrack = currentTrack;
          const wasPlaying = isPlaying;
          const previousPosition = currentPosition;

          currentTrack = state.track_window.current_track;
          isPlaying = !state.paused;
          currentPosition = state.position;
          duration = state.duration;
          
          // Check if we have a new track playing
          const newTrackUri = currentTrack ? currentTrack.uri : null;
          const trackChanged = newTrackUri !== currentTrackUri;
          
          if (trackChanged) {
            // Remove the previous track from queue if it was from our queue
            if (currentTrackUri && window.userRole === 'host') {
              removeTrackFromQueue(currentTrackUri);
            }
            currentTrackUri = newTrackUri;
          }

          updateNowPlaying(currentTrack);
          updatePlayPauseButton(isPlaying);
          updateProgress(currentPosition, duration);
          
          // Improved song end detection
          const songEnded = wasPlaying && !isPlaying && 
                           previousPosition > 0 && 
                           currentPosition === 0 && 
                           !trackChanged; // Make sure it's actually the end, not a track change
          
          // Also check if we're near the end of the track (within last 3 seconds) and stopped
          const nearEnd = currentPosition > (duration - 3000) && currentPosition > 0;
          const stoppedNearEnd = wasPlaying && !isPlaying && nearEnd;
          
          if ((songEnded || stoppedNearEnd) && window.userRole === 'host') {
            console.log('Song ended, auto-playing next track...');
            console.log('Track end detection details:', {
              songEnded,
              stoppedNearEnd,
              wasPlaying,
              isPlaying,
              previousPosition,
              currentPosition,
              nearEnd,
              userRole: window.userRole
            });
            setTimeout(() => {
              autoPlayNext();
            }, 1000);
          }
          
          // Start or stop progress tracking
          if (isPlaying) {
            startProgressTracking();
            startTrackEndDetection(); // Start monitoring for track end
          } else {
            stopProgressTracking();
            stopTrackEndDetection();
          }
        });

        // Connect to the player
        const success = await player.connect();
        if (success) {
          console.log('The Web Playback SDK successfully connected to Spotify!');
        } else {
          console.error('The Web Playback SDK could not connect to Spotify');
          updateConnectionStatus('üî¥ Connection failed');
        }

      } catch (error) {
        console.error('Error initializing Spotify player:', error);
        updateConnectionStatus('üî¥ Initialization failed');
      }
    }

    // Transfer playback to the Web Playback SDK device
    async function transferPlaybackToDevice(deviceId) {
      try {
        const response = await fetch('/playback/transfer', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ device_id: deviceId })
        });

        if (response.ok) {
          console.log('Successfully transferred playback to web player');
        } else {
          const error = await response.json();
          console.warn('Failed to transfer playback:', error.error);
        }
      } catch (error) {
        console.error('Error transferring playback:', error);
      }
    }

    // Progress tracking functions
    function startProgressTracking() {
      stopProgressTracking(); // Clear any existing interval
      progressInterval = setInterval(async () => {
        if (player && isPlaying) {
          try {
            const state = await player.getCurrentState();
            if (state) {
              currentPosition = state.position;
              updateProgress(currentPosition, duration);
            }
          } catch (error) {
            console.error('Error getting current state:', error);
          }
        }
      }, 1000);
    }

    function stopProgressTracking() {
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
    }

    function updateProgress(position, trackDuration) {
      const progressFill = document.getElementById('progress-fill');
      const currentTime = document.getElementById('current-time');
      const totalTime = document.getElementById('total-time');
      
      if (progressFill && trackDuration > 0) {
        const percentage = (position / trackDuration) * 100;
        progressFill.style.width = percentage + '%';
      }
      
      if (currentTime) {
        currentTime.textContent = formatTime(position);
      }
      
      if (totalTime) {
        totalTime.textContent = formatTime(trackDuration);
      }
    }

    // Seek to a specific position in the track
    async function seekToPosition(event) {
      if (!player || !currentTrack) return;
      
      const progressBar = event.currentTarget;
      const rect = progressBar.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const width = rect.width;
      const percentage = clickX / width;
      const seekPosition = Math.floor(duration * percentage);
      
      try {
        await player.seek(seekPosition);
        currentPosition = seekPosition;
        updateProgress(currentPosition, duration);
      } catch (error) {
        console.error('Error seeking:', error);
      }
    }

    function formatTime(ms) {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
    }

    // Playback control functions
    async function togglePlayback() {
      if (!player) return;
      
      try {
        await player.togglePlay();
      } catch (error) {
        console.error('Error toggling playback:', error);
      }
    }

    async function nextTrack() {
      // Use the auto-play system to get the most liked track
      await autoPlayNext();
    }

    async function previousTrack() {
      // Get previous track from our queue
      const queueItems = document.querySelectorAll('#queue li');
      if (queueItems.length === 0) return;
      
      // Find currently playing track
      let currentIndex = -1;
      for (let i = 0; i < queueItems.length; i++) {
        const trackUri = queueItems[i].getAttribute('data-track-uri');
        if (trackUri === currentTrackUri) {
          currentIndex = i;
          break;
        }
      }
      
      // Play previous track in queue
      const prevIndex = currentIndex - 1;
      if (prevIndex >= 0) {
        const prevTrackUri = queueItems[prevIndex].getAttribute('data-track-uri');
        await playTrackFromQueue(prevTrackUri);
      } else {
        console.log('No previous track in queue');
      }
    }

    async function setVolume(volume) {
      if (!player) return;
      
      try {
        await player.setVolume(volume / 100);
      } catch (error) {
        console.error('Error setting volume:', error);
      }
    }

    // Remove track from queue after it's played
    async function removeTrackFromQueue(trackUri) {
      try {
        const response = await fetch(`/queue/remove/${encodeURIComponent(trackUri)}`, {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          console.log('Track removed from queue:', trackUri);
        } else {
          console.log('Failed to remove track from queue:', trackUri);
        }
      } catch (error) {
        console.error('Error removing track from queue:', error);
      }
    }

    // Auto-play debounce to prevent multiple simultaneous calls
    let autoPlayInProgress = false;
    let lastAutoPlayTime = 0;

    // Auto-play the most liked track (silent operation)
    async function autoPlayNext() {
      const now = Date.now();
      console.log('autoPlayNext called', { 
        accessToken: !!accessToken, 
        deviceId, 
        userRole: window.userRole,
        autoPlayInProgress,
        timeSinceLastCall: now - lastAutoPlayTime
      });
      
      // Debounce: prevent multiple calls within 2 seconds
      if (autoPlayInProgress || (now - lastAutoPlayTime) < 2000) {
        console.log('Auto-play call blocked by debounce');
        return;
      }
      
      if (!accessToken || !deviceId) {
        console.log('Spotify player not connected for auto-play');
        return;
      }

      autoPlayInProgress = true;
      lastAutoPlayTime = now;

      try {
        console.log('Sending auto-play request to /queue/auto-play');
        const response = await fetch('/queue/auto-play', {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ device_id: deviceId })
        });

        console.log('Auto-play response status:', response.status);
        
        if (response.ok) {
          const result = await response.json();
          console.log(`Auto-played: ${result.message}`, result);
          
          // Show a subtle notification in the connection status
          updateConnectionStatus(`üéµ Auto-playing: ${result.track.track_name}`);
          setTimeout(() => {
            updateConnectionStatus('üü¢ Connected');
          }, 3000);
        } else {
          const error = await response.json();
          console.log('No suitable tracks for auto-play:', error.error);
          console.log('Full error response:', error);
        }
      } catch (error) {
        console.error('Error auto-playing track:', error);
      } finally {
        // Reset the flag after a delay to allow the next legitimate auto-play
        setTimeout(() => {
          autoPlayInProgress = false;
        }, 1000);
      }
    }

    // Play a specific track from the queue
    async function playTrackFromQueue(trackUri) {
      if (!accessToken || !deviceId) {
        alert('Spotify player not connected');
        return;
      }

      try {
        const response = await fetch('/playback/play', {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ 
            track_uri: trackUri,
            device_id: deviceId 
          })
        });

        if (!response.ok) {
          const error = await response.json();
          console.error('Error playing track:', error);
          
          // Provide more specific error messages
          if (response.status === 404) {
            alert('No active device found. Make sure Spotify is open and try refreshing the page.');
          } else if (error.error && error.error.includes('Premium')) {
            alert('Spotify Premium is required for web playback. Please upgrade your account.');
          } else {
            alert(error.error || 'Failed to play track');
          }
        } else {
          console.log('Successfully started playback');
          
          // Remove the track from queue after successful playback
          await removeTrackFromQueue(trackUri);
        }
      } catch (error) {
        console.error('Error playing track:', error);
        alert('Network error. Please check your connection and try again.');
      }
    }

    // Track end detection using progress tracking
    function startTrackEndDetection() {
      stopTrackEndDetection();
      
      trackEndCheckInterval = setInterval(async () => {
        if (player && isPlaying && currentTrack && duration > 0) {
          try {
            const state = await player.getCurrentState();
            if (state && state.position > (duration - 2000)) { // Within last 2 seconds
              console.log('Track ending soon, preparing auto-play...');
              
              // Schedule auto-play
              setTimeout(() => {
                if (window.userRole === 'host') {
                  console.log('Track ended via time check, auto-playing next...');
                  autoPlayNext();
                }
              }, duration - state.position + 500); // Play next track 500ms after current ends
              
              stopTrackEndDetection(); // Stop checking since we've scheduled the next track
            }
          } catch (error) {
            console.error('Error checking track end:', error);
          }
        }
      }, 1000); // Check every second
    }

    function stopTrackEndDetection() {
      if (trackEndCheckInterval) {
        clearInterval(trackEndCheckInterval);
        trackEndCheckInterval = null;
      }
    }

    // UI update functions
    function updateConnectionStatus(status) {
      const statusElement = document.getElementById('connection-status');
      if (statusElement) statusElement.textContent = status;
    }

    function updateNowPlaying(track) {
      const trackName = document.getElementById('current-track-name');
      const trackArtist = document.getElementById('current-track-artist');
      const albumImage = document.getElementById('album-image');
      const placeholder = document.getElementById('no-track-placeholder');
      
      if (track) {
        const name = track.name;
        const artists = track.artists.map(artist => artist.name).join(', ');
        const imageUrl = track.album.images[0]?.url;
        
        if (trackName) trackName.textContent = name;
        if (trackArtist) trackArtist.textContent = artists;
        
        if (imageUrl && albumImage) {
          albumImage.src = imageUrl;
          albumImage.style.display = 'block';
          if (placeholder) placeholder.style.display = 'none';
        } else {
          if (albumImage) albumImage.style.display = 'none';
          if (placeholder) placeholder.style.display = 'flex';
        }
      } else {
        if (trackName) trackName.textContent = 'No track playing';
        if (trackArtist) trackArtist.textContent = 'Connect to start playback';
        if (albumImage) albumImage.style.display = 'none';
        if (placeholder) placeholder.style.display = 'flex';
      }
    }

    function updatePlayPauseButton(playing) {
      const button = document.getElementById('play-pause-btn');
      if (button) {
        button.textContent = playing ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
      }
    }

    function enablePlaybackControls(enabled) {
      const playPause = document.getElementById('play-pause-btn');
      const next = document.getElementById('next-btn');
      const prev = document.getElementById('prev-btn');
      const volumeSlider = document.getElementById('volume-slider');
      
      if (playPause) playPause.disabled = !enabled;
      if (next) next.disabled = !enabled;
      if (prev) prev.disabled = !enabled;
      if (volumeSlider) volumeSlider.disabled = !enabled;
    }

    // Restart session function (for hosts)
    async function restartSession() {
      if (confirm('‚ö†Ô∏è RESTART SESSION\n\nThis will:\n‚Ä¢ Clear all sessions for everyone\n‚Ä¢ Remove current host\n‚Ä¢ Clear the entire queue\n‚Ä¢ Reset all votes\n‚Ä¢ Clear all chat messages\n‚Ä¢ Force all users to reconnect\n\nAre you sure you want to restart the entire session?')) {
        try {
          const response = await fetch('/restart-session', {
            method: 'POST',
            credentials: 'include',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          if (response.ok) {
            const data = await response.json();
            alert('‚úÖ ' + data.message + '\n\nRedirecting to start page...');
            window.location.href = '/';
          } else {
            const error = await response.json();
            alert('‚ùå Error restarting session: ' + (error.error || 'Unknown error'));
          }
        } catch (error) {
          console.error('Error restarting session:', error);
          alert('‚ùå Network error while restarting session. Please try again.');
        }
      }
    }

    socket.on("queue_updated", data => {
      const li = document.createElement("li");
      const trackId = data.track_uri;
      const safeTrackId = trackId.replace(/[^a-zA-Z0-9]/g, '_');
      const timestamp = new Date(data.timestamp || Date.now()).getTime();
      
      li.setAttribute('data-track-uri', trackId);
      li.setAttribute('data-timestamp', timestamp);
      li.className = 'queue-item';
      li.style.position = 'relative';
      li.innerHTML = `
        <span class="position-indicator" style="position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: bold;">#${queueCount + 1}</span>
        <div>
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <span style="font-weight: bold;">${data.track_name || data.track_uri}</span>
            <span class="vote-score" id="score-${safeTrackId}" style="background-color: #333; padding: 2px 8px; border-radius: 12px; font-size: 12px; color: #1db954;">Score: 0</span>
          </div>
          <small style="color: #666;">Added: ${new Date(data.timestamp || Date.now()).toLocaleTimeString()}</small>
          <div class="vote-buttons">
            <button class="vote-btn" onclick="voteTrack('${trackId}', 'up', this)">üëç</button>
            <span class="vote-count" id="up-${safeTrackId}">0</span>
            <button class="vote-btn" onclick="voteTrack('${trackId}', 'down', this)">üëé</button>
            <span class="vote-count" id="down-${safeTrackId}">0</span>
            ${window.userRole === 'host' ? `<button onclick="playTrackFromQueue('${trackId}')" style="background-color: #1db954; margin: 0 5px;">‚ñ∂Ô∏è Play</button>` : ''}
            <button class="recommendations-btn" onclick="loadRecs('${trackId}', '${safeTrackId}')">See Similar Tracks</button>
          </div>
          <div id="recs-${safeTrackId}" class="recommendations-list"></div>
        </div>
      `;
      document.getElementById("queue").appendChild(li);
      queueCount++;
      updateQueueDisplay();
      
      // Initialize vote data for this track if not exists
      if (!voteData[trackId]) {
        voteData[trackId] = { up: 0, down: 0 };
      }
    });

    // Add success handler for queue_add
    socket.on("queue_add_success", data => {
      console.log("Track successfully added to queue:", data);
      // Show success message briefly
      const successMsg = document.createElement("div");
      successMsg.style.cssText = `
        position: fixed; top: 20px; right: 20px; background: #1db954; 
        color: white; padding: 10px 20px; border-radius: 5px; z-index: 9999;
        font-weight: bold; box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      `;
      successMsg.textContent = data.message || "Track added to queue!";
      document.body.appendChild(successMsg);
      
      // Remove after 3 seconds
      setTimeout(() => {
        if (successMsg.parentNode) {
          successMsg.parentNode.removeChild(successMsg);
        }
      }, 3000);
    });

    socket.on("queue_cleared", () => {
      document.getElementById("queue").innerHTML = '';
      queueCount = 0;
      voteData = {};
      updateQueueDisplay();
    });

    socket.on("votes_cleared", () => {
      // Reset all vote displays to 0
      voteData = {};
      document.querySelectorAll('.vote-count').forEach(element => {
        element.textContent = '0';
      });
    });

    socket.on("chat_cleared", () => {
      document.getElementById("chat-messages").innerHTML = '';
    });

    socket.on("session_restarted", () => {
      // Reset player state
      currentTrack = null;
      isPlaying = false;
      currentTrackUri = null;
      currentPosition = 0;
      duration = 0;
      
      // Update UI
      updateNowPlaying(null);
      updatePlayPauseButton(false);
      updateProgress(0, 0);
      updateConnectionStatus('üî¥ Session Restarted');
      
      // Stop progress tracking
      stopProgressTracking();
      
      // Show notification
      alert('Session has been restarted. All data cleared. Please refresh if needed.');
    });

    socket.on("track_removed", (data) => {
      // Remove the track from the queue UI
      const trackElement = document.querySelector(`li[data-track-uri="${data.track_uri}"]`);
      if (trackElement) {
        trackElement.remove();
        queueCount--;
        updateQueueDisplay();
        console.log(`Removed from queue: ${data.track_name}`);
      }
    });

    socket.on("vote_updated", data => {
      const trackId = data.track_uri;
      const safeId = trackId.replace(/[^a-zA-Z0-9]/g, '_');
      const upElement = document.getElementById(`up-${safeId}`);
      const downElement = document.getElementById(`down-${safeId}`);
      const scoreElement = document.getElementById(`score-${safeId}`);
      
      if (upElement) upElement.textContent = data.up_votes;
      if (downElement) downElement.textContent = data.down_votes;
      
      // Update score display with enhanced styling
      const netScore = data.up_votes - data.down_votes;
      if (scoreElement) {
        scoreElement.textContent = `Score: ${netScore >= 0 ? '+' : ''}${netScore}`;
        
        // Color code the score with background
        if (netScore > 0) {
          scoreElement.style.color = '#1db954'; // Green for positive
          scoreElement.style.backgroundColor = 'rgba(29, 185, 84, 0.1)';
        } else if (netScore < 0) {
          scoreElement.style.color = '#e74c3c'; // Red for negative
          scoreElement.style.backgroundColor = 'rgba(231, 76, 60, 0.1)';
        } else {
          scoreElement.style.color = '#666'; // Gray for neutral
          scoreElement.style.backgroundColor = '#333';
        }
      }
      
      // Add pulse animation to the voted track
      const trackElement = document.querySelector(`li[data-track-uri="${trackId}"]`);
      if (trackElement) {
        trackElement.classList.remove('highlight-new-vote');
        // Force reflow to restart animation
        trackElement.offsetHeight;
        trackElement.classList.add('highlight-new-vote');
        
        // Remove the highlight after animation
        setTimeout(() => {
          trackElement.classList.remove('highlight-new-vote');
        }, 400);
      }
      
      voteData[trackId] = {
        up: data.up_votes,
        down: data.down_votes
      };
      
      // Reorder the queue based on updated votes
      reorderQueueByVotes();
    });

    socket.on("vote_confirmed", data => {
      console.log(`Vote confirmed: ${data.vote_type} on ${data.track_uri}`);
      // Vote was processed successfully - no visual feedback needed
    });

    socket.on("chat_message", data => {
      const chatMessages = document.getElementById("chat-messages");
      const messageDiv = document.createElement("div");
      messageDiv.className = "chat-message";
      messageDiv.innerHTML = `
        <span class="chat-user">${data.user}:</span> 
        ${data.message}
        <span class="chat-time">${new Date(data.timestamp || Date.now()).toLocaleTimeString()}</span>
      `;
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    });

    let votingInProgress = {}; // Track voting per track to prevent rapid clicking
    
    function voteTrack(trackUri, voteType, buttonElement) {
      // Ensure user is authenticated
      if (!window.userRole) {
        alert('Please log in to vote on tracks');
        return;
      }
      
      // Prevent rapid clicking on the same track
      const voteKey = `${trackUri}_${voteType}`;
      if (votingInProgress[voteKey]) {
        console.log('Vote already in progress for this track, ignoring click');
        return;
      }
      
      votingInProgress[voteKey] = true;
      
      // Add visual feedback to the clicked button
      if (buttonElement) {
        buttonElement.classList.remove('just-voted');
        // Force reflow to restart animation
        buttonElement.offsetHeight;
        buttonElement.classList.add('just-voted');
        
        // Disable the button to prevent double-clicking
        buttonElement.disabled = true;
        
        // Remove the animation class after it completes
        setTimeout(() => {
          buttonElement.classList.remove('just-voted');
        }, 300);
      }
      
      console.log(`Voting ${voteType} on track: ${trackUri}`);
      
      // Send vote to backend - let backend handle everything
      socket.emit('vote_add', {
        track_uri: trackUri,
        vote: voteType
      });
      
      // Clear the voting lock and re-enable button after a delay
      setTimeout(() => {
        votingInProgress[voteKey] = false;
        if (buttonElement) {
          buttonElement.disabled = false;
        }
      }, 1000); // 1 second delay to prevent rapid clicking
    }

    function sendChatMessage(event) {
      event.preventDefault();
      const input = document.getElementById('chat-input');
      const message = input.value.trim();
      
      if (message) {
        // Use session user info instead of random currentUser
        const user = window.displayName || window.userId || 'Anonymous';
        socket.emit('chat_message', {
          user: user,
          message: message
        });
        input.value = '';
      }
    }

    function toggleChat() {
      const chatBox = document.getElementById('floating-chat');
      const toggleBtn = document.getElementById('chat-toggle');
      
      chatBox.classList.toggle('minimized');
      toggleBtn.textContent = chatBox.classList.contains('minimized') ? '+' : '‚àí';
    }

    // Handle socket errors
    socket.on('error', function(error) {
      console.error('Socket error received:', error);
      
      // Show user-friendly error message
      if (error.message) {
        // Create a non-intrusive error notification
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #e74c3c;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          z-index: 1001;
          max-width: 300px;
          box-shadow: 0 4px 8px rgba(0,0,0,0.3);
          font-weight: bold;
        `;
        errorDiv.innerHTML = `
          ‚ö†Ô∏è ${error.message}
          <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 16px; cursor: pointer; margin-left: 10px;">√ó</button>
        `;
        document.body.appendChild(errorDiv);
        
        // Auto-remove after 8 seconds
        setTimeout(() => {
          if (errorDiv.parentElement) {
            errorDiv.remove();
          }
        }, 8000);
      }
      
      // If authentication error, fetch session info for debugging
      if (error.message && error.message.includes('Authentication')) {
        fetch('/session-info')
          .then(response => response.json())
          .then(sessionData => {
            console.log('Session data after auth error:', sessionData);
          })
          .catch(err => console.error('Failed to fetch session info after error:', err));
      }
    });

    function playTrack() {
      // TODO: Implement Spotify Web Playback SDK integration
      // This will require:
      // 1. Loading the Spotify Web Playback SDK
      // 2. Authenticating with Spotify Premium
      // 3. Creating a Web Playback instance
      // 4. Playing the first track in queue
      alert('Spotify Web Playback SDK integration coming soon!\n\nThis will require:\n- Spotify Premium account\n- Web Playback SDK setup\n- Device authorization');
    }

    function updateQueueDisplay() {
      const queueEmpty = document.getElementById("queue-empty");
      const clearBtn = document.getElementById("clear-queue-btn");
      
      if (queueCount === 0) {
        queueEmpty.style.display = "block";
        clearBtn.style.display = "none";
      } else {
        queueEmpty.style.display = "none";
        clearBtn.style.display = "inline-block";
      }
    }

    function reorderQueueByVotes() {
      const queueContainer = document.getElementById("queue");
      const queueItems = Array.from(queueContainer.children);
      
      // Store original positions
      const originalPositions = new Map();
      queueItems.forEach((item, index) => {
        const trackUri = item.getAttribute('data-track-uri');
        originalPositions.set(trackUri, index);
      });
      
      // Sort queue items by vote score (up votes - down votes), then by timestamp
      queueItems.sort((a, b) => {
        const trackUriA = a.getAttribute('data-track-uri');
        const trackUriB = b.getAttribute('data-track-uri');
        
        const votesA = voteData[trackUriA] || { up: 0, down: 0 };
        const votesB = voteData[trackUriB] || { up: 0, down: 0 };
        
        const scoreA = votesA.up - votesA.down;
        const scoreB = votesB.up - votesB.down;
        
        // Sort by score (descending), then by timestamp (ascending) for tie-breaking
        if (scoreB !== scoreA) {
          return scoreB - scoreA; // Higher score first
        }
        
        // If scores are equal, maintain original order (timestamp)
        const timestampA = a.getAttribute('data-timestamp') || 0;
        const timestampB = b.getAttribute('data-timestamp') || 0;
        return timestampA - timestampB;
      });
      
      // Calculate new positions and determine movement direction
      const movements = new Map();
      queueItems.forEach((item, newIndex) => {
        const trackUri = item.getAttribute('data-track-uri');
        const oldIndex = originalPositions.get(trackUri);
        
        if (oldIndex !== newIndex) {
          if (newIndex < oldIndex) {
            movements.set(trackUri, 'up');
          } else {
            movements.set(trackUri, 'down');
          }
        }
      });
      
      // Apply movement animations before reordering
      queueItems.forEach((item) => {
        const trackUri = item.getAttribute('data-track-uri');
        const movement = movements.get(trackUri);
        
        // Remove any existing animation classes
        item.classList.remove('moving-up', 'moving-down', 'highlight-new-vote');
        
        if (movement === 'up') {
          item.classList.add('moving-up');
        } else if (movement === 'down') {
          item.classList.add('moving-down');
        }
      });
      
      // Wait a brief moment for animations to start, then reorder
      setTimeout(() => {
        // Clear the queue container and re-append in new order
        queueContainer.innerHTML = '';
        queueItems.forEach((item, index) => {
          // Add class name for styling
          item.className = 'queue-item';
          
          // Add position indicator
          const positionIndicator = item.querySelector('.position-indicator');
          if (positionIndicator) {
            positionIndicator.textContent = `#${index + 1}`;
          } else {
            // Create position indicator if it doesn't exist
            const indicator = document.createElement('span');
            indicator.className = 'position-indicator';
            indicator.style.cssText = 'position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: bold;';
            indicator.textContent = `#${index + 1}`;
            item.style.position = 'relative';
            item.appendChild(indicator);
          }
          
          // Highlight the first track (next to play)
          if (index === 0) {
            item.classList.add('next-to-play');
          } else {
            item.classList.remove('next-to-play');
          }
          
          // Re-apply movement animations if they were active
          const trackUri = item.getAttribute('data-track-uri');
          const movement = movements.get(trackUri);
          if (movement === 'up') {
            item.classList.add('moving-up');
          } else if (movement === 'down') {
            item.classList.add('moving-down');
          }
          
          queueContainer.appendChild(item);
        });
        
        // Clean up animation classes after animation completes
        setTimeout(() => {
          queueItems.forEach((item) => {
            item.classList.remove('moving-up', 'moving-down');
          });
        }, 600);
        
      }, 50);
      
      console.log('Queue reordered by votes with animations');
    }

    async function clearQueue() {
      if (confirm('Are you sure you want to clear the entire queue?')) {
        try {
          const response = await fetch('/queue/clear', { 
            method: 'POST',
            credentials: 'include',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          if (response.ok) {
            // The socket event will handle UI update
            console.log('Queue cleared successfully');
          } else {
            const errorText = await response.text();
            console.error('Failed to clear queue:', response.status, errorText);
            if (response.status === 403) {
              alert('Only hosts can clear the queue. Please make sure you are logged in as a host.');
            } else {
              alert('Failed to clear queue: ' + response.status);
            }
          }
        } catch (err) {
          console.error('Error clearing queue:', err);
          alert('Error clearing queue: ' + err.message);
        }
      }
    }

    async function loadPlaylists() {
      try {
        console.log('loadPlaylists called - User role:', window.userRole);
        
        // Show loading indicator
        const playlistList = document.getElementById('playlist-list');
        playlistList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;"><div class="loading-spinner"></div> Loading playlists...</div>';
        
        console.log('Fetching playlists from /playlists/');
        const res = await fetch('/playlists/', {
          credentials: 'include'
        });
        
        console.log('Playlists response status:', res.status, 'redirected:', res.redirected);
        
        if (res.redirected) {
          console.log('Response was redirected, showing login');
          document.getElementById('login').style.display = 'block';
          return;
        }
        
        const data = await res.json();
        console.log('Playlists data received:', data);
        
        document.getElementById('login').style.display = 'none';
        document.getElementById('playlists').style.display = 'block';
        
        // Update the playlist section title based on user role
        const playlistsTitle = document.querySelector('#playlists h2');
        if (data.is_listener) {
          playlistsTitle.textContent = 'üéµ Host\'s Playlists';
        } else if (data.is_host) {
          playlistsTitle.textContent = 'Your Playlists';
        } else {
          playlistsTitle.textContent = 'Playlists';
        }
        
        const ul = document.getElementById('playlist-list');
        ul.innerHTML = ''; // Clear loading indicator
        
        console.log('Processing playlists - Total items:', data.items.length, 'Is listener:', data.is_listener, 'Is host:', data.is_host);
        
        // Visual confirmation that we're processing playlists
        console.log('About to update playlist list element with', data.items.length, 'items');
        
        // Show message if listener and no playlists
        if (data.is_listener && data.items.length === 0) {
          const messageDiv = document.createElement('div');
          messageDiv.style.cssText = `
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
            border: 2px dashed #444;
            border-radius: 8px;
            margin: 20px 0;
          `;
          messageDiv.innerHTML = `
            <div style="font-size: 2em; margin-bottom: 10px;">üéµ</div>
            ${data.message || 'No playlists shared yet'}<br><br>
            <small>When a host connects and browses their playlists, they'll appear here for you to explore!</small>
          `;
          ul.appendChild(messageDiv);
          return;
        }
        
        console.log('About to render playlists...');
        data.items.forEach(pl => {
          console.log('Rendering playlist:', pl.name, 'ID:', pl.id, 'Tracks:', pl.tracks ? pl.tracks.total : 'Unknown');
          const li = document.createElement('li');
          li.innerHTML = `
            <span>${pl.name}</span>
            <small>${pl.tracks ? pl.tracks.total : 'Unknown'} tracks</small>
            ${data.is_listener ? '<small style="color: #9C27B0;">üë§ Host\'s Playlist</small>' : ''}
          `;
          li.onclick = () => loadPlaylistTracks(pl.id);
          ul.appendChild(li);
        });
        console.log('Finished rendering', data.items.length, 'playlists');
        
        // Add listener mode info message
        if (data.is_listener && data.items.length > 0) {
          const infoDiv = document.createElement('div');
          infoDiv.style.cssText = `
            background: rgba(156, 39, 176, 0.1);
            padding: 10px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 0.85em;
            color: #ccc;
            text-align: center;
          `;
          infoDiv.innerHTML = 'üí° These are playlists shared by the current host. Click to explore!';
          ul.appendChild(infoDiv);
        }
        
      } catch (err) {
        console.error('Error loading playlists:', err);
        
        // Show error message with more details
        const ul = document.getElementById('playlist-list');
        ul.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #e74c3c;">
            <div style="font-size: 2em; margin-bottom: 10px;">‚ùå</div>
            Error loading playlists<br>
            <small style="color: #999; margin-top: 10px; display: block;">
              Error: ${err.message}<br>
              User Role: ${window.userRole}<br>
              Time: ${new Date().toLocaleTimeString()}
            </small>
            <button onclick="loadPlaylists()" style="
              margin-top: 10px; 
              padding: 5px 10px; 
              background: #1db954; 
              color: white; 
              border: none; 
              border-radius: 3px; 
              cursor: pointer;
            ">Try Again</button>
          </div>
        `;
      }
    }

    function queueTrack(trackUri, trackName) {
      console.log('queueTrack called with:', { trackUri, trackName });
      console.log('Socket connected:', socketConnected);
      console.log('User role:', window.userRole);
      
      if (!socketConnected) {
        console.error('Socket not connected');
        alert('Connection issue. Please refresh the page.');
        return;
      }
      
      // Allow both hosts and listeners to add tracks to the queue
      if (window.userRole !== 'host' && window.userRole !== 'listener') {
        alert('You must be a host or listener to add tracks to the queue.');
        return;
      }
      
      // Debug session info before attempting to queue
      fetch('/session-info', {
        credentials: 'include'
      })
               .then(response => response.json())
        .then(sessionData => {
          console.log('Current session data:', sessionData);
        })
        .catch(err => console.error('Failed to fetch session info:', err));
      
      socket.emit('queue_add', { 
        track_uri: trackUri,
        track_name: trackName
      });
      
      console.log('Emitted queue_add event');
    }

    async function loadPlaylistTracks(playlistId) {
      try {
        // Show loading indicator
        document.getElementById('playlists').style.display = 'none';
        document.getElementById('tracks').style.display = 'block';
        
        const trackList = document.getElementById('track-list');
        trackList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;"><div class="loading-spinner"></div> Loading tracks...</div>';
        
        const res = await fetch(`/playlists/${playlistId}/tracks`, {
          credentials: 'include'
        });
        if (res.redirected) {
          window.location = res.url;
          return;
        }
        const data = await res.json();
        
        // Update tracks section title
        const tracksTitle = document.querySelector('#tracks h2');
        if (data.guest_mode) {
          tracksTitle.textContent = 'üéµ Playlist Tracks (Guest View)';
        } else {
          tracksTitle.textContent = 'Playlist Tracks';
        }
        
        const ul = document.getElementById('track-list');
        ul.innerHTML = ''; // Clear loading indicator

        // Handle guest mode with no tracks
        if (data.guest_mode && data.items.length === 0) {
          const messageDiv = document.createElement('div');
          messageDiv.style.cssText = `
            text-align: center;
            padding: 30px 20px;
            color: #666;
            border: 2px dashed #444;
            border-radius: 8px;
            margin: 20px 0;
          `;
          messageDiv.innerHTML = `
            <div style="font-size: 2.5em; margin-bottom: 15px;">üéµ</div>
            <strong>${data.message || 'No tracks cached yet'}</strong><br><br>
            <small style="color: #999;">
              The host needs to browse this playlist first to cache the tracks for guests.<br>
              You can still vote on tracks that are already in the queue!
            </small><br><br>
            <button onclick="loadPlaylists()" style="
              background: linear-gradient(135deg, #9C27B0, #E91E63);
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              margin-top: 10px;
            ">‚Üê Back to Playlists</button>
          `;
          ul.appendChild(messageDiv);
          return;
        }

        // Display tracks
        data.items.forEach(item => {
          const t = item.track;
          if (t && t.name) { // Check if track exists (some tracks can be null)
            const li = document.createElement('li');
            li.innerHTML = `
              <div>
                <strong>${t.name}</strong><br>
                <small>${t.artists.map(a => a.name).join(', ')}</small>
                ${data.guest_mode ? '<small style="color: #9C27B0; font-size: 0.7em;">üë§ Cached for guests</small>' : ''}
              </div>
            `;
            const btn = document.createElement('button');
            
            // Show appropriate button based on role
            if (window.userRole === 'host') {
              btn.textContent = 'Add to Queue';
              btn.onclick = () => queueTrack(t.uri, `${t.name} - ${t.artists.map(a => a.name).join(', ')}`);
              li.appendChild(btn);
            } else if (window.userRole === 'listener') {
              btn.disabled = true;
              btn.textContent = 'Host Only';
              btn.style.opacity = '0.5';
              btn.title = 'Only the host can add tracks to the queue';
              li.appendChild(btn);
            } else {
              // Guests get a different message
              const guestMsg = document.createElement('small');
              guestMsg.style.cssText = 'color: #9C27B0; font-style: italic; margin-left: 10px;';
              guestMsg.textContent = '(Vote on queued tracks instead!)';
              li.appendChild(guestMsg);
            }
            
            ul.appendChild(li);
          }
        });
        
        // Add info for guest mode
        if (data.guest_mode && data.items.length > 0) {
          const infoDiv = document.createElement('div');
          infoDiv.style.cssText = `
            background: rgba(156, 39, 176, 0.1);
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 0.85em;
            color: #ccc;
            text-align: center;
          `;
          infoDiv.innerHTML = `
            üí° <strong>Guest Mode:</strong> You can see tracks but can't add them to the queue.<br>
            Head to the queue section to vote on tracks that are already queued!
          `;
          ul.appendChild(infoDiv);
        }
        
      } catch (err) {
        console.error('Error loading playlist tracks:', err);
        const ul = document.getElementById('track-list');
        ul.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #e74c3c;">
            <div style="font-size: 2em; margin-bottom: 10px;">‚ùå</div>
            Error loading tracks. Please try again later.
          </div>
        `;
      }
    }

    window.onload = function() {
      // Immediately hide login div if user is authenticated
      if (window.userRole && (window.userRole === 'host' || window.userRole === 'listener')) {
        const loginDiv = document.getElementById('login');
        if (loginDiv) {
          console.log('Immediately hiding login div for authenticated user:', window.userRole);
          loginDiv.style.display = 'none';
          loginDiv.style.visibility = 'hidden';
          loginDiv.style.height = '0px';
          loginDiv.style.overflow = 'hidden';
        }
        
        const roleSelection = document.querySelector('.role-selection');
        if (roleSelection) {
          roleSelection.style.display = 'none';
        }
      }
      
      // Load playlists for hosts and listeners (listeners see host's playlists)
      if (window.userRole === 'host' || window.userRole === 'listener') {
        loadPlaylists();
      }
      loadInitialQueue();
      
      // Initialize role-based UI
      console.log('Page loaded, initializing role-based UI...');
      initializeRoleBasedUI();
      
      // Fetch user profile if logged in (not guest or listener without Spotify)
      if (window.userRole === 'host') {
        fetchUserProfile();
      }
      
      document.getElementById('back-btn').onclick = function() {
        document.getElementById('tracks').style.display = 'none';
        document.getElementById('playlists').style.display = 'block';
        // clear track list
        document.getElementById('track-list').innerHTML = '';
      };
    };

    async function loadInitialQueue() {
      try {
        const response = await fetch('/queue');
        const data = await response.json();
        queueCount = data.count;
        updateQueueDisplay();
      } catch (err) {
        console.error('Error loading initial queue:', err);
      }
    }

    // Load recommendations for a track
    async function loadRecs(trackUri, safeTrackId) {
      const recsContainer = document.getElementById(`recs-${safeTrackId}`);
      const btn = event.target;
      
      // Toggle visibility if already loaded
      if (recsContainer.classList.contains('visible')) {
        recsContainer.classList.remove('visible');
        btn.textContent = 'See Similar Tracks';
        return;
      }
      
      // Show loading state
      btn.textContent = 'Loading...';
      btn.disabled = true;
      
      try {
        const response = await fetch(`/recommend/${encodeURIComponent(trackUri)}`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        const recommendations = data.recommendations || [];
        
        if (recommendations.length === 0) {
          const message = data.message || 'No similar tracks found.';
          recsContainer.innerHTML = `<div class="recommendation-item" style="color: #666; font-style: italic;">${message}</div>`;
        } else {
          recsContainer.innerHTML = recommendations.map(rec => `
            <div class="recommendation-item">
              <a href="${rec.url}" target="_blank" class="recommendation-link">
                <strong>${rec.artist}</strong> ‚Äî ${rec.title}
              </a>
              ${rec.source ? `<small style="color: #666; margin-left: 10px; font-size: 10px;">(${rec.source})</small>` : ''}
            </div>
          `).join('');
        }
        
        recsContainer.classList.add('visible');
        btn.textContent = 'Hide Similar Tracks';
        
      } catch (error) {
        console.error('Error loading recommendations:', error);
        recsContainer.innerHTML = '<div class="recommendation-item" style="color: #e74c3c;">Error loading recommendations. Please try again.</div>';
        recsContainer.classList.add('visible');
        btn.textContent = 'See Similar Tracks';
      } finally {
        btn.disabled = false;
      }
    }

    // Role-based UI initialization
    function initializeRoleBasedUI() {
      const role = window.userRole || 'guest';
      console.log('Initializing UI for role:', role);
      
      // Update UI based on role
      if (role === 'guest') {
        // Show guest-friendly UI
        console.log('Setting up guest UI - can vote and chat');
        
        // Hide login section for guests (they can participate without auth)
        const loginDiv = document.getElementById('login');
        if (loginDiv) {
          loginDiv.style.display = 'none';
        }
        
        // Show all interactive features for guests
        document.getElementById('queue-section').style.display = 'block';
        document.getElementById('floating-chat').style.display = 'block';
        
        // Hide host-only controls for guests
        const clearQueueBtn = document.getElementById('clear-queue-btn');
        if (clearQueueBtn) {
          clearQueueBtn.style.display = 'none';
        }
        
        // Hide restart button for guests
        const restartBtn = document.getElementById('host-restart-btn');
        if (restartBtn) {
          restartBtn.style.display = 'none';
        }
        
        // Hide playback controls for guests (they can only view what's playing)
        const playbackControls = document.getElementById('playback-controls');
        if (playbackControls) {
          playbackControls.style.display = 'none';
        }
        
        const volumeControl = document.getElementById('volume-control');
        if (volumeControl) {
          volumeControl.style.display = 'none';
        }
        
        // Show role indicator for guests
        addRoleIndicator('guest');
        
        // Add guest welcome message
        addGuestWelcomeMessage();
        
      } else if (role === 'listener') {
        // Hide host-only controls for listeners
        const clearQueueBtn = document.getElementById('clear-queue-btn');
        if (clearQueueBtn) {
          clearQueueBtn.style.display = 'none';
        }
        
        // Hide restart button for listeners
        const restartBtn = document.getElementById('host-restart-btn');
        if (restartBtn) {
          restartBtn.style.display = 'none';
        }
        
        // Hide playback controls for listeners (they can only view what's playing)
        const playbackControls = document.getElementById('playback-controls');
        if (playbackControls) {
          playbackControls.style.display = 'none';
        }
        
        const volumeControl = document.getElementById('volume-control');
        if (volumeControl) {
          volumeControl.style.display = 'none';
        }
        
        // Update playback section title to indicate view-only
        const playbackTitle = document.querySelector('#playback-section h3');
        if (playbackTitle) {
          playbackTitle.textContent = 'üéµ Now Playing (View Only)';
        }
        
        // Hide login section for listeners
        const loginDiv = document.getElementById('login');
        if (loginDiv) {
          console.log('Hiding login div for listener');
          loginDiv.style.display = 'none';
          loginDiv.style.visibility = 'hidden';
          loginDiv.style.height = '0px';
          loginDiv.style.overflow = 'hidden';
        }
        
        // Also hide any role selection elements
        const roleSelection = document.querySelector('.role-selection');
        if (roleSelection) {
          console.log('Hiding role selection for listener');
          roleSelection.style.display = 'none';
        }
        
        // Show role indicator
        addRoleIndicator('listener');
      } else if (role === 'host') {
        // Show all controls for hosts
        console.log('Setting up host UI - restart button should be visible');
        
        // Force hide login/role selection for authenticated hosts
        const loginDiv = document.getElementById('login');
        if (loginDiv) {
          console.log('Hiding login div for host');
          loginDiv.style.display = 'none';
          loginDiv.style.visibility = 'hidden';
          loginDiv.style.height = '0px';
          loginDiv.style.overflow = 'hidden';
        }
        
        // Also hide any other login-related elements that might be causing gaps
        const roleSelection = document.querySelector('.role-selection');
        if (roleSelection) {
          console.log('Hiding role selection for host');
          roleSelection.style.display = 'none';
        }
        
        // Ensure restart button is visible for hosts
        const restartBtn = document.getElementById('host-restart-btn');
        if (restartBtn) {
          console.log('Restart button found, ensuring visibility');
          restartBtn.style.display = 'inline-block';
          restartBtn.style.visibility = 'visible';
        } else {
          console.error('Restart button not found!');
        }
        
        // Show role indicator
        addRoleIndicator('host');
      }
    }

    function addRoleIndicator(role) {
      const h1 = document.querySelector('h1');
      if (h1 && !document.querySelector('.role-indicator')) {
        const roleSpan = document.createElement('span');
        roleSpan.className = 'role-indicator';
        roleSpan.style.cssText = 'font-size: 0.6em; background: #1db954; color: white; padding: 4px 8px; border-radius: 12px; margin-left: 10px;';
        roleSpan.textContent = role.toUpperCase();
        h1.appendChild(roleSpan);
        
        // Always show a container for user info and logout button
        const userContainer = document.createElement('div');
        userContainer.style.cssText = 'font-size: 0.7em; color: #666; margin-top: 5px; display: flex; align-items: center; gap: 10px;';
        
        // Show display name if available, otherwise show generic welcome
        if (window.displayName && window.displayName !== 'Guest') {
          const nameSpan = document.createElement('span');
          nameSpan.textContent = `Welcome, ${window.displayName}!`;
          userContainer.appendChild(nameSpan);
        } else if (role === 'guest') {
          const nameSpan = document.createElement('span');
          nameSpan.textContent = 'Welcome, Guest!';
          userContainer.appendChild(nameSpan);
        }
        
        // Add logout/role switch button for all roles
        if (role === 'host') {
          const signOutBtn = document.createElement('button');
          signOutBtn.textContent = 'üö™ Sign Out as Host';
          signOutBtn.style.cssText = `
            font-size: 1em; 
            background: #e74c3c; 
            color: white; 
            border: none; 
            padding: 8px 12px; 
            border-radius: 4px; 
            cursor: pointer;
            transition: background-color 0.3s;
          `;
          signOutBtn.onmouseover = () => signOutBtn.style.backgroundColor = '#c0392b';
          signOutBtn.onmouseout = () => signOutBtn.style.backgroundColor = '#e74c3c';
          signOutBtn.onclick = signOutAsHost;
          userContainer.appendChild(signOutBtn);
        } else {
          // Add logout/role switch button for listeners and guests
          const switchBtn = document.createElement('button');
          switchBtn.textContent = role === 'guest' ? 'üîë Login or Switch Role' : 'üîÑ Switch Role';
          switchBtn.style.cssText = `
            font-size: 1em; 
            background: #1db954; 
            color: white; 
            border: none; 
            padding: 8px 12px; 
            border-radius: 4px; 
            cursor: pointer;
            transition: background-color 0.3s;
          `;
          switchBtn.onmouseover = () => switchBtn.style.backgroundColor = '#1ed760';
          switchBtn.onmouseout = () => switchBtn.style.backgroundColor = '#1db954';
          switchBtn.onclick = () => {
            window.location.href = '/logout';
          };
          userContainer.appendChild(switchBtn);
        }
        
        h1.appendChild(userContainer);
      }
    }

    function addGuestWelcomeMessage() {
      const h1 = document.querySelector('h1');
      if (h1 && !document.querySelector('.guest-welcome')) {
        const welcomeDiv = document.createElement('div');
        welcomeDiv.className = 'guest-welcome';
        welcomeDiv.style.cssText = `
          background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(233, 30, 99, 0.1));
          padding: 20px;
          border-radius: 12px;
          margin: 20px 0;
          border: 1px solid rgba(156, 39, 176, 0.3);
          font-size: 0.95em;
          color: white;
          box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        `;
        welcomeDiv.innerHTML = `
          <div style="text-align: center;">
            <strong style="font-size: 1.1em;">üëã Welcome, Guest!</strong><br><br>
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 15px; margin: 15px 0;">
              <div style="flex: 1; min-width: 120px; text-align: center;">
                <div style="font-size: 1.5em; margin-bottom: 5px;">üó≥Ô∏è</div>
                <strong>Vote on Tracks</strong><br>
                <small style="color: #ccc;">Help decide what plays next</small>
              </div>
              <div style="flex: 1; min-width: 120px; text-align: center;">
                <div style="font-size: 1.5em; margin-bottom: 5px;">üí¨</div>
                <strong>Join the Chat</strong><br>
                <small style="color: #ccc;">Talk with other listeners</small>
              </div>
              <div style="flex: 1; min-width: 120px; text-align: center;">
                <div style="font-size: 1.5em; margin-bottom: 5px;">üéµ</div>
                <strong>Browse Playlists</strong><br>
                <small style="color: #ccc;">See what's available</small>
              </div>
            </div>
            <small style="color: #ccc; font-style: italic;">
              No sign-up required! To host your own session, <a href="javascript:void(0)" onclick="location.reload()" style="color: #E91E63; text-decoration: underline;">click here</a> to go back.
            </small>
          </div>
        `;
        
        // Insert after the h1
        h1.parentNode.insertBefore(welcomeDiv, h1.nextSibling);
      }
    }

    // Sign out as host function
    async function signOutAsHost() {
      if (confirm('Are you sure you want to sign out as host? This will end the session for everyone.')) {
        try {
          const response = await fetch('/sign-out-host', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          if (response.ok) {
            alert('You have been signed out as host. Redirecting to role selection...');
            window.location.href = '/select-role';
          } else {
            alert('Error signing out. Please try again.');
          }
        } catch (error) {
          console.error('Error signing out:', error);
          alert('Error signing out. Please try again.');
        }
      }
    }

    // Debug function to check player state
    async function debugPlayerState() {
      console.log('=== SPOTIFY PLAYER DEBUG ===');
      console.log('Access Token:', accessToken ? 'Present' : 'Missing');
      console.log('Device ID:', deviceId || 'Missing');
      console.log('Player Object:', player ? 'Present' : 'Missing');
      
      if (player) {
        try {
          const state = await player.getCurrentState();
          console.log('Player State:', state);
        } catch (error) {
          console.log('Error getting player state:', error);
        }
      }
      
      // Check available devices
      try {
        const response = await fetch('/playback/devices');
        const devices = await response.json();
        console.log('Available Devices:', devices);
      } catch (error) {
        console.log('Error getting devices:', error);
      }
      
      console.log('=== END DEBUG ===');
    }

    // Add debug button to console (for development)
    window.debugPlayer = debugPlayerState;

    // Fetch user profile function
    async function fetchUserProfile() {
      try {
        console.log('Fetching user profile to update display name...');
        const response = await fetch('/fetch-user-profile', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const data = await response.json();
          console.log('User profile fetched:', data);
          
          // Update global variables
          window.userId = data.user_id;
          window.displayName = data.display_name;
          
          // Update the role indicator with the real name
          updateUserDisplayName(data.display_name);
          
          // Only reload playlists for hosts (listeners get host's playlists automatically)
          if (window.userRole === 'host') {
            console.log('Reloading playlists with updated user profile...');
            loadPlaylists();
          }
          
        } else {
          const error = await response.json();
          console.warn('Could not fetch user profile:', error.error);
        }
      } catch (error) {
        console.error('Error fetching user profile:', error);
      }
    }

    // Update user display name in the UI
    function updateUserDisplayName(displayName) {
      // Find and update the welcome message in the role indicator
      const userContainer = document.querySelector('.role-indicator').nextElementSibling;
      if (userContainer) {
        const nameSpan = userContainer.querySelector('span');
        if (nameSpan && nameSpan.textContent.startsWith('Welcome,')) {
          nameSpan.textContent = `Welcome, ${displayName}!`;
          console.log('Updated display name to:', displayName);
        }
      }
    }

    // Transfer playback to the Web Playback SDK device
  </script>
</body>
</html>
