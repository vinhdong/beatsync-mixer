<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>BeatSync Mixer</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #000;
      color: white;
      padding-top: 120px; /* Space for Spotify player */
      overflow-x: hidden; /* Prevent horizontal scroll */
    }

    /* Spotify Web Player - Fixed at top */
    #spotify-player-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: linear-gradient(90deg, #121212 0%, #282828 100%);
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      border-bottom: 1px solid #333;
      backdrop-filter: blur(10px); /* Add blur effect for better separation */
    }

    #full-player {
      width: 100%;
      height: 100%;
      padding: 0 20px;
    }

    .player-content {
      display: flex;
      align-items: center;
      height: 100%;
      max-width: 1200px;
      margin: 0 auto;
      gap: 20px;
    }

    .track-info {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
      min-width: 0;
    }

    .track-details {
      min-width: 0;
      flex: 1;
    }

    .track-name {
      font-size: 14px;
      font-weight: 600;
      color: white;
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .track-artist {
      font-size: 12px;
      color: #b3b3b3;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .player-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-btn {
      background: none;
      border: none;
      color: #b3b3b3;
      font-size: 16px;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: all 0.2s;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-btn:hover:not(:disabled) {
      color: white;
      background-color: rgba(255,255,255,0.1);
    }

    .control-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .play-btn {
      background-color: white !important;
      color: black !important;
      font-size: 14px;
      width: 32px;
      height: 32px;
    }

    .play-btn:hover:not(:disabled) {
      background-color: #f0f0f0 !important;
      transform: scale(1.05);
    }

    .progress-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      flex: 1;
      max-width: 200px;
    }

    .progress-bar-container {
      width: 100%;
      height: 4px;
      background: #4f4f4f;
      border-radius: 2px;
      cursor: pointer;
      position: relative;
    }

    .progress-bar {
      width: 100%;
      height: 100%;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: #1db954;
      border-radius: 2px;
      width: 0%;
      transition: width 0.1s;
    }

    .time-info {
      font-size: 11px;
      color: #b3b3b3;
      white-space: nowrap;
    }

    .volume-section {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 120px;
    }

    .volume-icon {
      color: #b3b3b3;
      font-size: 14px;
    }

    .volume-slider {
      width: 80px;
      height: 4px;
      background: #4f4f4f;
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
    }

    .status {
      font-size: 11px;
      color: #b3b3b3;
      min-width: 100px;
      text-align: right;
    }

    /* Loading spinner */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid #333;
      border-radius: 50%;
      border-top-color: #1db954;
      animation: spin 1s ease-in-out infinite;
      margin-right: 10px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Main content area */
    .main-content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
      min-height: calc(100vh - 120px);
      border-radius: 8px 8px 0 0;
      position: relative;
      z-index: 1; /* Ensure content stays below fixed player */
    }

    h1 {
      color: #1db954;
      text-align: center;
      margin-bottom: 30px;
    }

    /* Header with restart button */
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      position: relative;
      z-index: 10; /* Ensure header is above other content */
    }

    h2 {
      color: #333;
      border-bottom: 2px solid #1db954;
      padding-bottom: 10px;
    }

    #login {
      text-align: center;
      margin: 40px 0;
    }

    #login a {
      display: inline-block;
      background-color: #1db954;
      color: white;
      padding: 12px 24px;
      text-decoration: none;
      border-radius: 50px;
      font-weight: bold;
      transition: background-color 0.3s;
    }

    #login a:hover {
      background-color: #1ed760;
    }

    ul {
      list-style: none;
      padding: 0;
    }

    li {
      background: white;
      margin: 10px 0;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #333;
    }

    li:hover {
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    button {
      background-color: #1db954;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #1ed760;
    }

    #back-btn {
      background-color: #666;
      margin-bottom: 15px;
    }

    #back-btn:hover {
      background-color: #777;
    }

    /* Side by side layout for playlists and queue */
    .content-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }

    .section {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      color: #333;
    }

    /* Floating Chat Box */
    #floating-chat {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 320px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
      z-index: 999;
      transition: all 0.3s ease;
      border: 1px solid #ddd;
    }

    #floating-chat.minimized {
      height: 50px;
      overflow: hidden;
    }

    #chat-header {
      background: #1db954;
      color: white;
      padding: 12px 16px;
      border-radius: 12px 12px 0 0;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }

    #chat-toggle {
      background: none;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      padding: 0;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #chat-content {
      height: 300px;
      display: flex;
      flex-direction: column;
      color: #333;
    }

    #chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      background: #f9f9f9;
      border-bottom: 1px solid #eee;
    }

    .chat-message {
      margin-bottom: 8px;
      padding: 6px 8px;
      border-radius: 4px;
      background: white;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      font-size: 13px;
    }

    .chat-user {
      font-weight: bold;
      color: #1db954;
      font-size: 12px;
    }

    .chat-time {
      font-size: 10px;
      color: #666;
      float: right;
    }

    #chat-form {
      padding: 12px;
      display: flex;
      gap: 8px;
      background: white;
      border-radius: 0 0 12px 12px;
    }

    #chat-input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 20px;
      font-size: 13px;
      outline: none;
    }

    #chat-form button {
      padding: 8px 16px;
      font-size: 12px;
      border-radius: 20px;
    }
    .vote-buttons {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 5px;
    }
    .vote-btn {
      background: none;
      border: none;
      font-size: 1.2em;
      cursor: pointer;
      padding: 5px;
      border-radius: 3px;
      transition: all 0.2s ease;
      position: relative;
    }
    .vote-btn:hover {
      background-color: #f0f0f0;
      transform: scale(1.1);
    }
    .vote-btn:active {
      transform: scale(0.9);
    }
    .vote-btn.just-voted {
      animation: buttonPulse 0.3s ease-out;
    }
    
    @keyframes buttonPulse {
      0% {
        transform: scale(1);
        background-color: transparent;
      }
      50% {
        transform: scale(1.2);
        background-color: rgba(29, 185, 84, 0.3);
      }
      100% {
        transform: scale(1);
        background-color: #f0f0f0;
      }
    }
    .vote-count {
      font-size: 0.9em;
      color: #666;
    }
    .recommendations-btn {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 0.8em;
      cursor: pointer;
      transition: background-color 0.3s;
      margin-left: 10px;
    }
    .recommendations-btn:hover {
      background-color: #2980b9;
    }
    .recommendations-list {
      margin-top: 10px;
      padding: 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
      border-left: 3px solid #3498db;
      display: none;
    }
    .recommendations-list.visible {
      display: block;
    }
    .recommendation-item {
      padding: 5px 0;
      border-bottom: 1px solid #dee2e6;
    }
    .recommendation-item:last-child {
      border-bottom: none;
    }
    .recommendation-link {
      color: #3498db;
      text-decoration: none;
      font-weight: 500;
    }
    .recommendation-link:hover {
      text-decoration: underline;
    }
    #playback-section {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      text-align: center;
    }
    #play-btn {
      background-color: #1db954;
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 50px;
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    #play-btn:hover {
      background-color: #1ed760;
    }
    #play-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    /* Playback control styles */
    #playback-controls button {
      background-color: #1db954;
      border: none;
      color: white;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #playback-controls button:hover:not(:disabled) {
      background-color: #1ed760;
      transform: scale(1.05);
    }
    #playback-controls button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    #play-pause-btn {
      width: 55px !important;
      height: 55px !important;
    }
    #volume-control input[type="range"] {
      -webkit-appearance: none;
      height: 5px;
      border-radius: 5px;
      background: #ddd;
      outline: none;
    }
    #volume-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #1db954;
      cursor: pointer;
    }
    #now-playing {
      border-left: 4px solid #1db954;
    }
    .next-to-play {
      border-left: 4px solid #1db954 !important;
      background: linear-gradient(90deg, rgba(29, 185, 84, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%) !important;
    }
    .next-to-play::before {
      content: "▶️ NEXT";
      position: absolute;
      top: 8px;
      right: 8px;
      background: #1db954;
      color: white;
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 10px;
      font-weight: bold;
    }
    .queue-item {
      position: relative;
      transition: all 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
      transform: translateY(0);
    }
    
    .queue-item.moving-up {
      animation: slideUp 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    
    .queue-item.moving-down {
      animation: slideDown 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    
    @keyframes slideUp {
      0% {
        transform: translateY(0);
        background-color: rgba(29, 185, 84, 0.1);
      }
      50% {
        transform: translateY(-10px);
        background-color: rgba(29, 185, 84, 0.3);
        box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
      }
      100% {
        transform: translateY(0);
        background-color: transparent;
      }
    }
    
    @keyframes slideDown {
      0% {
        transform: translateY(0);
        background-color: rgba(255, 165, 0, 0.1);
      }
      50% {
        transform: translateY(10px);
        background-color: rgba(255, 165, 0, 0.3);
        box-shadow: 0 4px 12px rgba(255, 165, 0, 0.3);
      }
      100% {
        transform: translateY(0);
        background-color: transparent;
      }
    }
    
    .queue-item.highlight-new-vote {
      animation: pulseVote 0.4s ease-in-out;
    }
    
    @keyframes pulseVote {
      0% {
        transform: scale(1);
        background-color: transparent;
      }
      50% {
        transform: scale(1.02);
        background-color: rgba(29, 185, 84, 0.2);
      }
      100% {
        transform: scale(1);
        background-color: transparent;
      }
    }
    .role-indicator {
      background-color: #1db954;
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8em;
      font-weight: bold;
    }
    
    #host-restart-btn {
      background-color: #e74c3c !important;
      color: white !important;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      font-weight: bold;
      transition: all 0.3s ease;
      position: relative;
      z-index: 100; /* Ensure button is always visible */
      min-width: 120px;
    }
    
    #host-restart-btn:hover {
      background-color: #c0392b !important;
      transform: scale(1.05);    }
    
    /* Role Selection Styles */
    .role-selection {
      text-align: center;
      max-width: 600px;
      margin: 0 auto;
      padding: 40px 20px;
    }
    
    .role-selection h2 {
      color: white;
      margin-bottom: 30px;
      font-size: 1.5em;
    }
    
    .role-options {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .role-option {
      flex: 1;
      min-width: 160px;
      max-width: 200px;
    }
    
    .role-btn {
      display: block;
      padding: 20px 15px;
      border-radius: 12px;
      text-decoration: none;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: inherit;
      font-size: 1em;
      width: 100%;
      position: relative;
      overflow: hidden;
    }
    
    .role-btn small {
      display: block;
      font-size: 0.8em;
      margin-top: 8px;
      opacity: 0.9;
    }
    
    .host-btn {
      background: linear-gradient(135deg, #1db954 0%, #1ed760 100%);
      color: white;
    }
    
    .listener-btn {
      background: linear-gradient(135deg, #2196F3 0%, #21CBF3 100%);
      color: white;
    }
    
    .guest-btn {
      background: linear-gradient(135deg, #9C27B0 0%, #E91E63 100%);
      color: white;
    }
    
    .role-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }
    
    .host-btn:hover {
      background: linear-gradient(135deg, #1ed760 0%, #1db954 100%);
    }
    
    .listener-btn:hover {
      background: linear-gradient(135deg, #21CBF3 0%, #2196F3 100%);
    }
    
    .guest-btn:hover {
      background: linear-gradient(135deg, #E91E63 0%, #9C27B0 100%);
    }
    
    @media (max-width: 768px) {
      .role-options {
        flex-direction: column;
        align-items: center;
      }
      
      .role-option {
        width: 100%;
        max-width: 280px;
      }
    }

    @media (max-width: 768px) {
      .container {
        grid-template-columns: 1fr;
      }
      
      .main-content > div:first-child {
        flex-direction: column;
        gap: 10px;
      }
      
      #host-restart-btn {
        font-size: 0.8em;
        padding: 6px 12px;
      }
    }
  </style>
  <!-- Spotify Web Playback SDK -->
  <script src="https://sdk.scdn.co/spotify-player.js"></script>
</head>
<body>
  <!-- Spotify Web Player - Fixed at top -->
  <div id="spotify-player-container">
    <div id="spotify-embed-wrapper" style="display: none;">
      <iframe id="spotify-player" 
              style="border-radius:12px" 
              src="" 
              width="100%" 
              height="152" 
              frameBorder="0" 
              allowfullscreen="" 
              allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
              loading="lazy">
      </iframe>
    </div>
    <div id="full-player">
      <div class="player-content">
        <div class="track-info">
          <div id="album-art">
            <img id="album-image" src="" alt="Album Art" style="width: 60px; height: 60px; border-radius: 4px; display: none;">
            <div id="no-track-placeholder" style="width: 60px; height: 60px; background: #333; border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #666;">♪</div>
          </div>
          <div class="track-details">
            <div class="track-name" id="current-track-name">No track playing</div>
            <div class="track-artist" id="current-track-artist">Connect to start playback</div>
          </div>
        </div>
        
        <div class="player-controls">
          <button class="control-btn" id="prev-btn" onclick="previousTrack()" disabled>⏮️</button>
          <button class="control-btn play-btn" id="play-pause-btn" onclick="togglePlayback()" disabled>▶️</button>
          <button class="control-btn" id="next-btn" onclick="nextTrack()" disabled>⏭️</button>
        </div>
        
        <div class="progress-section">
          <div class="progress-bar-container" onclick="seekToPosition(event)">
            <div class="progress-bar" id="progress-bar">
              <div class="progress-fill" id="progress-fill"></div>
            </div>
          </div>
          <div class="time-info">
            <span id="current-time">0:00</span> / <span id="total-time">0:00</span>
          </div>
        </div>
        
        <div class="volume-section">
          <span class="volume-icon">🔊</span>
          <input type="range" class="volume-slider" id="volume-slider" min="0" max="100" value="50" onchange="setVolume(this.value)">
        </div>
        
        <div class="status" id="connection-status">🔴 Disconnected</div>
      </div>
    </div>
  </div>

  <!-- Main content area -->
  <div class="main-content">
    <div class="header-container">
      <h1>🎵 BeatSync Mixer</h1>
      <div style="display: flex; gap: 10px; align-items: center;">
        <button id="logout-btn" onclick="window.location.href='/logout'" style="
          background-color: #1db954; 
          color: white; 
          border: none; 
          padding: 8px 16px; 
          border-radius: 4px; 
          cursor: pointer; 
          font-size: 0.9em; 
          font-weight: bold;
          transition: all 0.3s ease;
        " onmouseover="this.style.backgroundColor='#1ed760'" onmouseout="this.style.backgroundColor='#1db954'">
          🔄 Switch Role
        </button>
        <button id="host-restart-btn" onclick="restartSession()">
          🔄 Restart Session
        </button>
      </div>
    </div>

    <div id="login" style="display: none;">
      <div class="role-selection">
        <h2>Choose how to join BeatSync Mixer</h2>
        <div class="role-options">
          <div class="role-option">
            <a href="/login?role=host" class="role-btn host-btn">
              🎵 Host Session
              <small>Control music, manage playlists</small>
            </a>
          </div>
          <div class="role-option">
            <a href="/join-listener" class="role-btn listener-btn">
              🎧 Join as Listener
              <small>No Spotify account required - join instantly!</small>
            </a>
          </div>
          <div class="role-option">
            <button onclick="continueAsGuest()" class="role-btn guest-btn">
              👋 Continue as Guest
              <small>Vote, chat, browse - no login required</small>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Side-by-side content grid -->
    <div class="content-grid">
      <!-- Left side: Playlists and Tracks -->
      <div class="section">
        <div id="playlists" style="display:block;">
          <h2>Your Playlists</h2>
          <ul id="playlist-list"></ul>
        </div>

        <div id="tracks" style="display:none;">
          <button id="back-btn" style="margin-bottom:10px;">← Back to Playlists</button>
          <h2>Playlist Tracks</h2>
          <ul id="track-list"></ul>
        </div>
      </div>

      <!-- Right side: Queue -->
      <div class="section">
        <div id="queue-section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2>Current Queue <small style="font-size: 0.6em; color: #666; font-weight: normal;">(ordered by votes)</small></h2>
            <button id="clear-queue-btn" onclick="clearQueue()" style="background-color: #e74c3c;">Clear Queue</button>
          </div>
          <ul id="queue"></ul>
          <div id="queue-empty" style="display: none; text-align: center; color: #666; padding: 20px;">
            No tracks in queue. Add some music! 🎵
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Floating Chat Box -->
  <div id="floating-chat">
    <div id="chat-header" onclick="toggleChat()">
      <span>💬 Chat</span>
      <button id="chat-toggle">−</button>
    </div>
    <div id="chat-content">
      <div id="chat-messages"></div>
      <form id="chat-form" onsubmit="sendChatMessage(event)">
        <input type="text" id="chat-input" placeholder="Type a message..." maxlength="200">
        <button type="submit">Send</button>
      </form>
    </div>
  </div>

  <!-- TODO: Add voting system for queue items -->
  <!-- TODO: Add chat functionality -->
  <!-- TODO: Integrate Spotify Web Playback SDK for playback control -->

  <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
  <script>
    // Immediate role initialization - run before any other code
    (function() {
      // Check if user role is injected from server
      const role = window.userRole;
      const loginDiv = document.getElementById('login');
      
      console.log('Immediate initialization - Role:', role, 'Login div exists:', !!loginDiv);
      
      // If no role is defined or it's undefined, this means we weren't properly authenticated
      if (!role || role === 'undefined' || role === '' || role === 'null') {
        console.log('No valid role found, checking if we should redirect');
        
        // If we're on the main page but have no role, redirect to role selection
        if (window.location.pathname === '/' || window.location.pathname === '/index.html') {
          console.log('On main page but no valid role, redirecting to role selection');
          window.location.href = '/select-role?error=session_lost';
          return;
        }
        
        // Otherwise, show login interface
        if (loginDiv) {
          loginDiv.style.display = 'block';
          loginDiv.style.visibility = 'visible';
          console.log('Login div shown for unauthenticated user');
        }
        
      } else if (role && role !== 'guest' && loginDiv) {
        // Hide login for authenticated users immediately
        loginDiv.style.display = 'none';
        loginDiv.style.visibility = 'hidden';
        console.log('Login div hidden for authenticated user with role:', role);
      } else if (!role && loginDiv) {
        // Show login for unauthenticated users
        loginDiv.style.display = 'block';
        loginDiv.style.visibility = 'visible';
        console.log('Login div shown for unauthenticated user');
      }
    })();

    const socket = io();
    let queueCount = 0;
    let currentUser = 'User_' + Math.random().toString(36).substr(2, 9); // Generate random user ID
    let voteData = {}; // Store vote counts for tracks
    let socketConnected = false; // Track socket connection status

    // Socket connection events
    socket.on('connect', function() {
      console.log('Socket.IO connected');
      socketConnected = true;
    });

    socket.on('disconnect', function() {
      console.log('Socket.IO disconnected');
      socketConnected = false;
    });

    socket.on('error', function(error) {
      console.error('Socket.IO error:', error);
      
      // Show user-friendly error message
      if (error.message) {
        alert('Error: ' + error.message);
      }
      
      // If authentication error, fetch session info for debugging
      if (error.message && error.message.includes('Authentication')) {
        fetch('/session-info')
          .then(response => response.json())
          .then(sessionData => {
            console.log('Session data after auth error:', sessionData);
          })
          .catch(err => console.error('Failed to fetch session info after error:', err));
      }
    });

    // Playback state events from host
    socket.on("playback_started", data => {
      console.log('Playback started:', data);
      
      // Update UI to show something is playing
      if (data.track_uri) {
        // Find the track in the queue and highlight it as playing
        const trackElements = document.querySelectorAll(`li[data-track-uri="${data.track_uri}"]`);
        trackElements.forEach(el => {
          el.style.background = 'rgba(29, 185, 84, 0.2)';
          el.style.border = '2px solid #1db954';
          
          // Add playing indicator
          const playingIndicator = el.querySelector('.playing-indicator');
          if (!playingIndicator) {
            const indicator = document.createElement('span');
            indicator.className = 'playing-indicator';
            indicator.innerHTML = ' 🎵 Playing';
            indicator.style.color = '#1db954';
            indicator.style.fontWeight = 'bold';
            el.appendChild(indicator);
          }
        });
      }
      
      // Show notification for listeners
      if (window.userRole === 'listener') {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #1db954;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          z-index: 1000;
          font-weight: bold;
        `;
        notification.textContent = '🎵 Host started playing music';
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      }
    });

    socket.on("playback_paused", data => {
      console.log('Playback paused:', data);
      
      // Remove playing indicators from all tracks
      const playingIndicators = document.querySelectorAll('.playing-indicator');
      playingIndicators.forEach(indicator => indicator.remove());
      
      // Remove highlight from all tracks
      const trackElements = document.querySelectorAll('li[data-track-uri]');
      trackElements.forEach(el => {
        el.style.background = '';
        el.style.border = '';
      });
      
      // Show notification for listeners
      if (window.userRole === 'listener') {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #666;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          z-index: 1000;
          font-weight: bold;
        `;
        notification.textContent = '⏸️ Host paused the music';
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      }
    });

    // Playlists became available from host
    socket.on("playlists_available", data => {
      console.log('Playlists available from host:', data);
      
      // Show notification for listeners
      if (window.userRole === 'listener') {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #1db954;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          z-index: 1000;
          font-weight: bold;
        `;
        notification.textContent = `🎵 ${data.host_name} shared ${data.playlist_count} playlists!`;
        document.body.appendChild(notification);
        
        // Auto-reload playlists for listeners
        setTimeout(() => {
          loadPlaylists();
        }, 1000);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 5000);
      }
    });

    // Spotify Web Playback SDK variables
    let player = null;
    let deviceId = null;
    let currentTrack = null;
    let isPlaying = false;
    let accessToken = null;
    let currentTrackUri = null;
    let currentPosition = 0;
    let duration = 0;
    let progressInterval = null;

    // Track end detection using progress tracking
    let trackEndCheckInterval = null;

    // Continue as guest function
    function continueAsGuest() {
      // Hide the login section
      const loginDiv = document.getElementById('login');
      if (loginDiv) {
        loginDiv.style.display = 'none';
      }
      
      // Set role to guest and initialize UI
      window.userRole = 'guest';
      window.userId = 'guest_' + Math.random().toString(36).substr(2, 9);
      window.displayName = 'Guest';
      
      console.log('Continuing as guest:', window.userId);
      
      // Initialize guest UI
      initializeRoleBasedUI();
      
      // Load only shared data for guests (no playlists since they don't have Spotify auth)
      loadQueue();
      
      // Socket.IO will automatically connect when the page loads
      console.log('Guest setup complete');
    }

    // Initialize Spotify Web Playback SDK
    window.onSpotifyWebPlaybackSDKReady = () => {
      initializeSpotifyPlayer();
    };

    async function initializeSpotifyPlayer() {
      // Only initialize Spotify Player for hosts
      if (window.userRole !== 'host') {
        console.log('Skipping Spotify Player initialization - user is not host');
        return;
      }
      
      try {
        // Get access token from backend
        const tokenResponse = await fetch('/playback/spotify-token', {
          credentials: 'include'
        });
        if (!tokenResponse.ok) {
          console.log('Failed to get Spotify token, status:', tokenResponse.status);
          updateConnectionStatus('🔴 Not authenticated');
          console.log('User not authenticated with Spotify');
          return;
        }
        
        const tokenData = await tokenResponse.json();
        accessToken = tokenData.access_token;
        console.log('Successfully retrieved access token for Spotify Player:', accessToken ? 'Token present' : 'No token');

        // Initialize the Spotify Player
        player = new Spotify.Player({
          name: 'BeatSync Mixer Player',
          getOAuthToken: cb => { cb(accessToken); },
          volume: 0.5
        });

        // Error handling
        player.addListener('initialization_error', ({ message }) => {
          console.error('Spotify Player initialization error:', message);
          updateConnectionStatus('🔴 Initialization error');
          if (message.includes('Spotify Premium')) {
            alert('Spotify Premium is required for web playback. Please upgrade your account to use the music player.');
          }
        });

        player.addListener('authentication_error', ({ message }) => {
          console.error('Spotify Player authentication error:', message);
          console.error('This usually means missing scopes or invalid token');
          updateConnectionStatus('🔴 Authentication error');
          // Only show popup for hosts, and make it less intrusive
          if (window.userRole === 'host') {
            console.log('Authentication error for host - checking token and scopes');
            // Check what token we have
            fetch('/playback/spotify-token', { credentials: 'include' })
              .then(r => r.json())
              .then(data => console.log('Current token data:', data))
              .catch(e => console.error('Failed to get token info:', e));
            
            // Show a less intrusive notification instead of alert
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
              position: fixed; top: 120px; right: 20px; 
              background: #f44336; color: white; padding: 15px; 
              border-radius: 8px; z-index: 1001; max-width: 300px;
              box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            `;
            errorDiv.innerHTML = `
              <strong>⚠️ Spotify Player Authentication Issue</strong><br>
              <small>Error: ${message}<br>You may need to re-authenticate to get proper permissions for music playback.</small>
              <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 16px; cursor: pointer; margin-left: 10px;">×</button>
            `;
            document.body.appendChild(errorDiv);
            // Auto-remove after 15 seconds
            setTimeout(() => {
              if (errorDiv.parentElement) errorDiv.remove();
            }, 15000);
          }
        });

        player.addListener('account_error', ({ message }) => {
          console.error('Spotify Player account error:', message);
          updateConnectionStatus('🔴 Premium required');
          alert('Spotify Premium is required for web playback. Please upgrade your account.');
        });

        player.addListener('playback_error', ({ message }) => {
          console.error('Spotify Player playback error:', message);
          alert('Playback error: ' + message);
        });

        // Ready
        player.addListener('ready', ({ device_id }) => {
          console.log('Ready with Device ID', device_id);
          deviceId = device_id;
          updateConnectionStatus('🟢 Connected');
          enablePlaybackControls(true);
          
          // Transfer playback to this device
          transferPlaybackToDevice(device_id);
        });

        // Not Ready
        player.addListener('not_ready', ({ device_id }) => {
          console.log('Device ID has gone offline', device_id);
          updateConnectionStatus('🔴 Disconnected');
          enablePlaybackControls(false);
        });

        // Player state changed
        player.addListener('player_state_changed', (state) => {
          if (!state) return;

          const previousTrack = currentTrack;
          const wasPlaying = isPlaying;
          const previousPosition = currentPosition;

          currentTrack = state.track_window.current_track;
          isPlaying = !state.paused;
          currentPosition = state.position;
          duration = state.duration;
          
          // Check if we have a new track playing
          const newTrackUri = currentTrack ? currentTrack.uri : null;
          const trackChanged = newTrackUri !== currentTrackUri;
          
          if (trackChanged) {
            // Remove the previous track from queue if it was from our queue
            if (currentTrackUri && window.userRole === 'host') {
              removeTrackFromQueue(currentTrackUri);
            }
            currentTrackUri = newTrackUri;
          }

          updateNowPlaying(currentTrack);
          updatePlayPauseButton(isPlaying);
          updateProgress(currentPosition, duration);
          
          // Improved song end detection
          const songEnded = wasPlaying && !isPlaying && 
                           previousPosition > 0 && 
                           currentPosition === 0 && 
                           !trackChanged; // Make sure it's actually the end, not a track change
          
          // Also check if we're near the end of the track (within last 3 seconds) and stopped
          const nearEnd = currentPosition > (duration - 3000) && currentPosition > 0;
          const stoppedNearEnd = wasPlaying && !isPlaying && nearEnd;
          
          if ((songEnded || stoppedNearEnd) && window.userRole === 'host') {
            console.log('Song ended, auto-playing next track...');
            console.log('Track end detection details:', {
              songEnded,
              stoppedNearEnd,
              wasPlaying,
              isPlaying,
              previousPosition,
              currentPosition,
              nearEnd,
              userRole: window.userRole
            });
            setTimeout(() => {
              autoPlayNext();
            }, 1000);
          }
          
          // Start or stop progress tracking
          if (isPlaying) {
            startProgressTracking();
            startTrackEndDetection(); // Start monitoring for track end
          } else {
            stopProgressTracking();
            stopTrackEndDetection();
          }
        });

        // Connect to the player
        const success = await player.connect();
        if (success) {
          console.log('The Web Playback SDK successfully connected to Spotify!');
        } else {
          console.error('The Web Playback SDK could not connect to Spotify');
          updateConnectionStatus('🔴 Connection failed');
        }

      } catch (error) {
        console.error('Error initializing Spotify player:', error);
        updateConnectionStatus('🔴 Initialization failed');
      }
    }

    // Transfer playback to the Web Playback SDK device
    async function transferPlaybackToDevice(deviceId) {
      try {
        const response = await fetch('/playback/transfer', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ device_id: deviceId })
        });

        if (response.ok) {
          console.log('Successfully transferred playback to web player');
        } else {
          const error = await response.json();
          console.warn('Failed to transfer playback:', error.error);
        }
      } catch (error) {
        console.error('Error transferring playback:', error);
      }
    }

    // Progress tracking functions
    function startProgressTracking() {
      stopProgressTracking(); // Clear any existing interval
      progressInterval = setInterval(async () => {
        if (player && isPlaying) {
          try {
            const state = await player.getCurrentState();
            if (state) {
              currentPosition = state.position;
              updateProgress(currentPosition, duration);
            }
          } catch (error) {
            console.error('Error getting current state:', error);
          }
        }
      }, 1000);
    }

    function stopProgressTracking() {
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
    }

    function updateProgress(position, trackDuration) {
      const progressFill = document.getElementById('progress-fill');
      const currentTime = document.getElementById('current-time');
      const totalTime = document.getElementById('total-time');
      
      if (progressFill && trackDuration > 0) {
        const percentage = (position / trackDuration) * 100;
        progressFill.style.width = percentage + '%';
      }
      
      if (currentTime) {
        currentTime.textContent = formatTime(position);
      }
      
      if (totalTime) {
        totalTime.textContent = formatTime(trackDuration);
      }
    }

    // Seek to a specific position in the track
    async function seekToPosition(event) {
      if (!player || !currentTrack) return;
      
      const progressBar = event.currentTarget;
      const rect = progressBar.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const width = rect.width;
      const percentage = clickX / width;
      const seekPosition = Math.floor(duration * percentage);
      
      try {
        await player.seek(seekPosition);
        currentPosition = seekPosition;
        updateProgress(currentPosition, duration);
      } catch (error) {
        console.error('Error seeking:', error);
      }
    }

    function formatTime(ms) {
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      return minutes + ':' + (seconds < 10 ? '0' : '') + seconds;
    }

    // Playback control functions
    async function togglePlayback() {
      if (!player) return;
      
      try {
        await player.togglePlay();
      } catch (error) {
        console.error('Error toggling playback:', error);
      }
    }

    async function nextTrack() {
      // Use the auto-play system to get the most liked track
      await autoPlayNext();
    }

    async function previousTrack() {
      // Get previous track from our queue
      const queueItems = document.querySelectorAll('#queue li');
      if (queueItems.length === 0) return;
      
      // Find currently playing track
      let currentIndex = -1;
      for (let i = 0; i < queueItems.length; i++) {
        const trackUri = queueItems[i].getAttribute('data-track-uri');
        if (trackUri === currentTrackUri) {
          currentIndex = i;
          break;
        }
      }
      
      // Play previous track in queue
      const prevIndex = currentIndex - 1;
      if (prevIndex >= 0) {
        const prevTrackUri = queueItems[prevIndex].getAttribute('data-track-uri');
        await playTrackFromQueue(prevTrackUri);
      } else {
        console.log('No previous track in queue');
      }
    }

    async function setVolume(volume) {
      if (!player) return;
      
      try {
        await player.setVolume(volume / 100);
      } catch (error) {
        console.error('Error setting volume:', error);
      }
    }

    // Remove track from queue after it's played
    async function removeTrackFromQueue(trackUri) {
      try {
        const response = await fetch(`/queue/remove/${encodeURIComponent(trackUri)}`, {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          console.log('Track removed from queue:', trackUri);
        } else {
          console.log('Failed to remove track from queue:', trackUri);
        }
      } catch (error) {
        console.error('Error removing track from queue:', error);
      }
    }

    // Auto-play debounce to prevent multiple simultaneous calls
    let autoPlayInProgress = false;
    let lastAutoPlayTime = 0;

    // Auto-play the most liked track (silent operation)
    async function autoPlayNext() {
      const now = Date.now();
      console.log('autoPlayNext called', { 
        accessToken: !!accessToken, 
        deviceId, 
        userRole: window.userRole,
        autoPlayInProgress,
        timeSinceLastCall: now - lastAutoPlayTime
      });
      
      // Debounce: prevent multiple calls within 2 seconds
      if (autoPlayInProgress || (now - lastAutoPlayTime) < 2000) {
        console.log('Auto-play call blocked by debounce');
        return;
      }
      
      if (!accessToken || !deviceId) {
        console.log('Spotify player not connected for auto-play');
        return;
      }

      autoPlayInProgress = true;
      lastAutoPlayTime = now;

      try {
        console.log('Sending auto-play request to /queue/auto-play');
        const response = await fetch('/queue/auto-play', {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ device_id: deviceId })
        });

        console.log('Auto-play response status:', response.status);
        
        if (response.ok) {
          const result = await response.json();
          console.log(`Auto-played: ${result.message}`, result);
          
          // Show a subtle notification in the connection status
          updateConnectionStatus(`🎵 Auto-playing: ${result.track.track_name}`);
          setTimeout(() => {
            updateConnectionStatus('🟢 Connected');
          }, 3000);
        } else {
          const error = await response.json();
          console.log('No suitable tracks for auto-play:', error.error);
          console.log('Full error response:', error);
        }
      } catch (error) {
        console.error('Error auto-playing track:', error);
      } finally {
        // Reset the flag after a delay to allow the next legitimate auto-play
        setTimeout(() => {
          autoPlayInProgress = false;
        }, 1000);
      }
    }

    // Play a specific track from the queue
    async function playTrackFromQueue(trackUri) {
      if (!accessToken || !deviceId) {
        alert('Spotify player not connected');
        return;
      }

      try {
        const response = await fetch('/playback/play', {
          method: 'POST',
          credentials: 'include',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ 
            track_uri: trackUri,
            device_id: deviceId 
          })
        });

        if (!response.ok) {
          const error = await response.json();
          console.error('Error playing track:', error);
          
          // Provide more specific error messages
          if (response.status === 404) {
            alert('No active device found. Make sure Spotify is open and try refreshing the page.');
          } else if (error.error && error.error.includes('Premium')) {
            alert('Spotify Premium is required for web playback. Please upgrade your account.');
          } else {
            alert(error.error || 'Failed to play track');
          }
        } else {
          console.log('Successfully started playback');
          
          // Remove the track from queue after successful playback
          await removeTrackFromQueue(trackUri);
        }
      } catch (error) {
        console.error('Error playing track:', error);
        alert('Network error. Please check your connection and try again.');
      }
    }

    // Track end detection using progress tracking
    function startTrackEndDetection() {
      stopTrackEndDetection();
      
      trackEndCheckInterval = setInterval(async () => {
        if (player && isPlaying && currentTrack && duration > 0) {
          try {
            const state = await player.getCurrentState();
            if (state && state.position > (duration - 2000)) { // Within last 2 seconds
              console.log('Track ending soon, preparing auto-play...');
              
              // Schedule auto-play
              setTimeout(() => {
                if (window.userRole === 'host') {
                  console.log('Track ended via time check, auto-playing next...');
                  autoPlayNext();
                }
              }, duration - state.position + 500); // Play next track 500ms after current ends
              
              stopTrackEndDetection(); // Stop checking since we've scheduled the next track
            }
          } catch (error) {
            console.error('Error checking track end:', error);
          }
        }
      }, 1000); // Check every second
    }

    function stopTrackEndDetection() {
      if (trackEndCheckInterval) {
        clearInterval(trackEndCheckInterval);
        trackEndCheckInterval = null;
      }
    }

    // UI update functions
    function updateConnectionStatus(status) {
      const statusElement = document.getElementById('connection-status');
      if (statusElement) statusElement.textContent = status;
    }

    function updateNowPlaying(track) {
      const trackName = document.getElementById('current-track-name');
      const trackArtist = document.getElementById('current-track-artist');
      const albumImage = document.getElementById('album-image');
      const placeholder = document.getElementById('no-track-placeholder');
      
      if (track) {
        const name = track.name;
        const artists = track.artists.map(artist => artist.name).join(', ');
        const imageUrl = track.album.images[0]?.url;
        
        if (trackName) trackName.textContent = name;
        if (trackArtist) trackArtist.textContent = artists;
        
        if (imageUrl && albumImage) {
          albumImage.src = imageUrl;
          albumImage.style.display = 'block';
          if (placeholder) placeholder.style.display = 'none';
        } else {
          if (albumImage) albumImage.style.display = 'none';
          if (placeholder) placeholder.style.display = 'flex';
        }
      } else {
        if (trackName) trackName.textContent = 'No track playing';
        if (trackArtist) trackArtist.textContent = 'Connect to start playback';
        if (albumImage) albumImage.style.display = 'none';
        if (placeholder) placeholder.style.display = 'flex';
      }
    }

    function updatePlayPauseButton(playing) {
      const button = document.getElementById('play-pause-btn');
      if (button) {
        button.textContent = playing ? '⏸️' : '▶️';
      }
    }

    function enablePlaybackControls(enabled) {
      const playPause = document.getElementById('play-pause-btn');
      const next = document.getElementById('next-btn');
      const prev = document.getElementById('prev-btn');
      const volumeSlider = document.getElementById('volume-slider');
      
      if (playPause) playPause.disabled = !enabled;
      if (next) next.disabled = !enabled;
      if (prev) prev.disabled = !enabled;
      if (volumeSlider) volumeSlider.disabled = !enabled;
    }

    // Restart session function (for hosts)
    async function restartSession() {
      if (confirm('⚠️ RESTART SESSION\n\nThis will:\n• Clear all sessions for everyone\n• Remove current host\n• Clear the entire queue\n• Reset all votes\n• Clear all chat messages\n• Force all users to reconnect\n\nAre you sure you want to restart the entire session?')) {
        try {
          const response = await fetch('/restart-session', {
            method: 'POST',
            credentials: 'include',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          if (response.ok) {
            const data = await response.json();
            alert('✅ ' + data.message + '\n\nRedirecting to start page...');
            window.location.href = '/';
          } else {
            const error = await response.json();
            alert('❌ Error restarting session: ' + (error.error || 'Unknown error'));
          }
        } catch (error) {
          console.error('Error restarting session:', error);
          alert('❌ Network error while restarting session. Please try again.');
        }
      }
    }

    socket.on("queue_updated", data => {
      const li = document.createElement("li");
      const trackId = data.track_uri;
      const safeTrackId = trackId.replace(/[^a-zA-Z0-9]/g, '_');
      const timestamp = new Date(data.timestamp || Date.now()).getTime();
      
      li.setAttribute('data-track-uri', trackId);
      li.setAttribute('data-timestamp', timestamp);
      li.className = 'queue-item';
      li.style.position = 'relative';
      li.innerHTML = `
        <span class="position-indicator" style="position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: bold;">#${queueCount + 1}</span>
        <div>
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <span style="font-weight: bold;">${data.track_name || data.track_uri}</span>
            <span class="vote-score" id="score-${safeTrackId}" style="background-color: #333; padding: 2px 8px; border-radius: 12px; font-size: 12px; color: #1db954;">Score: 0</span>
          </div>
          <small style="color: #666;">Added: ${new Date(data.timestamp || Date.now()).toLocaleTimeString()}</small>
          <div class="vote-buttons">
            <button class="vote-btn" onclick="voteTrack('${trackId}', 'up', this)">👍</button>
            <span class="vote-count" id="up-${safeTrackId}">0</span>
            <button class="vote-btn" onclick="voteTrack('${trackId}', 'down', this)">👎</button>
            <span class="vote-count" id="down-${safeTrackId}">0</span>
            ${window.userRole === 'host' ? `<button onclick="playTrackFromQueue('${trackId}')" style="background-color: #1db954; margin: 0 5px;">▶️ Play</button>` : ''}
            <button class="recommendations-btn" onclick="loadRecs('${trackId}', '${safeTrackId}')">See Similar Tracks</button>
          </div>
          <div id="recs-${safeTrackId}" class="recommendations-list"></div>
        </div>
      `;
      document.getElementById("queue").appendChild(li);
      queueCount++;
      updateQueueDisplay();
      
      // Initialize vote data for this track if not exists
      if (!voteData[trackId]) {
        voteData[trackId] = { up: 0, down: 0 };
      }
    });

    // Add success handler for queue_add
    socket.on("queue_add_success", data => {
      console.log("Track successfully added to queue:", data);
      // Show success message briefly
      const successMsg = document.createElement("div");
      successMsg.style.cssText = `
        position: fixed; top: 20px; right: 20px; background: #1db954; 
        color: white; padding: 10px 20px; border-radius: 5px; z-index: 9999;
        font-weight: bold; box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      `;
      successMsg.textContent = data.message || "Track added to queue!";
      document.body.appendChild(successMsg);
      
      // Remove after 3 seconds
      setTimeout(() => {
        if (successMsg.parentNode) {
          successMsg.parentNode.removeChild(successMsg);
        }
      }, 3000);
    });

    socket.on("queue_cleared", () => {
      document.getElementById("queue").innerHTML = '';
      queueCount = 0;
      voteData = {};
      updateQueueDisplay();
    });

    socket.on("votes_cleared", () => {
      // Reset all vote displays to 0
      voteData = {};
      document.querySelectorAll('.vote-count').forEach(element => {
        element.textContent = '0';
      });
    });

    socket.on("chat_cleared", () => {
      document.getElementById("chat-messages").innerHTML = '';
    });

    socket.on("session_restarted", () => {
      // Reset player state
      currentTrack = null;
      isPlaying = false;
      currentTrackUri = null;
      currentPosition = 0;
      duration = 0;
      
      // Update UI
      updateNowPlaying(null);
      updatePlayPauseButton(false);
      updateProgress(0, 0);
      updateConnectionStatus('🔴 Session Restarted');
      
      // Stop progress tracking
      stopProgressTracking();
      
      // Show notification
      alert('Session has been restarted. All data cleared. Please refresh if needed.');
    });

    socket.on("track_removed", (data) => {
      // Remove the track from the queue UI
      const trackElement = document.querySelector(`li[data-track-uri="${data.track_uri}"]`);
      if (trackElement) {
        trackElement.remove();
        queueCount--;
        updateQueueDisplay();
        console.log(`Removed from queue: ${data.track_name}`);
      }
    });

    socket.on("vote_updated", data => {
      const trackId = data.track_uri;
      const safeId = trackId.replace(/[^a-zA-Z0-9]/g, '_');
      const upElement = document.getElementById(`up-${safeId}`);
      const downElement = document.getElementById(`down-${safeId}`);
      const scoreElement = document.getElementById(`score-${safeId}`);
      
      if (upElement) upElement.textContent = data.up_votes;
      if (downElement) downElement.textContent = data.down_votes;
      
      // Update score display with enhanced styling
      const netScore = data.up_votes - data.down_votes;
      if (scoreElement) {
        scoreElement.textContent = `Score: ${netScore >= 0 ? '+' : ''}${netScore}`;
        
        // Color code the score with background
        if (netScore > 0) {
          scoreElement.style.color = '#1db954'; // Green for positive
          scoreElement.style.backgroundColor = 'rgba(29, 185, 84, 0.1)';
        } else if (netScore < 0) {
          scoreElement.style.color = '#e74c3c'; // Red for negative
          scoreElement.style.backgroundColor = 'rgba(231, 76, 60, 0.1)';
        } else {
          scoreElement.style.color = '#666'; // Gray for neutral
          scoreElement.style.backgroundColor = '#333';
        }
      }
      
      // Add pulse animation to the voted track
      const trackElement = document.querySelector(`li[data-track-uri="${trackId}"]`);
      if (trackElement) {
        trackElement.classList.remove('highlight-new-vote');
        // Force reflow to restart animation
        trackElement.offsetHeight;
        trackElement.classList.add('highlight-new-vote');
        
        // Remove the highlight after animation
        setTimeout(() => {
          trackElement.classList.remove('highlight-new-vote');
        }, 400);
      }
      
      voteData[trackId] = {
        up: data.up_votes,
        down: data.down_votes
      };
      
      // Reorder the queue based on updated votes
      reorderQueueByVotes();
    });

    socket.on("vote_confirmed", data => {
      console.log(`Vote confirmed: ${data.vote_type} on ${data.track_uri}`);
      // Vote was processed successfully - no visual feedback needed
    });

    socket.on("chat_message", data => {
      const chatMessages = document.getElementById("chat-messages");
      const messageDiv = document.createElement("div");
      messageDiv.className = "chat-message";
      messageDiv.innerHTML = `
        <span class="chat-user">${data.user}:</span> 
        ${data.message}
        <span class="chat-time">${new Date(data.timestamp || Date.now()).toLocaleTimeString()}</span>
      `;
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    });

    let votingInProgress = {}; // Track voting per track to prevent rapid clicking
    
    function voteTrack(trackUri, voteType, buttonElement) {
      // Ensure user is authenticated
      if (!window.userRole) {
        alert('Please log in to vote on tracks');
        return;
      }
      
      // Prevent rapid clicking on the same track
      const voteKey = `${trackUri}_${voteType}`;
      if (votingInProgress[voteKey]) {
        console.log('Vote already in progress for this track, ignoring click');
        return;
      }
      
      votingInProgress[voteKey] = true;
      
      // Add visual feedback to the clicked button
      if (buttonElement) {
        buttonElement.classList.remove('just-voted');
        // Force reflow to restart animation
        buttonElement.offsetHeight;
        buttonElement.classList.add('just-voted');
        
        // Disable the button to prevent double-clicking
        buttonElement.disabled = true;
        
        // Remove the animation class after it completes
        setTimeout(() => {
          buttonElement.classList.remove('just-voted');
        }, 300);
      }
      
      console.log(`Voting ${voteType} on track: ${trackUri}`);
      
      // Send vote to backend - let backend handle everything
      socket.emit('vote_add', {
        track_uri: trackUri,
        vote: voteType
      });
      
      // Clear the voting lock and re-enable button after a delay
      setTimeout(() => {
        votingInProgress[voteKey] = false;
        if (buttonElement) {
          buttonElement.disabled = false;
        }
      }, 1000); // 1 second delay to prevent rapid clicking
    }

    function sendChatMessage(event) {
      event.preventDefault();
      const input = document.getElementById('chat-input');
      const message = input.value.trim();
      
      if (message) {
        // Use session user info instead of random currentUser
        const user = window.displayName || window.userId || 'Anonymous';
        socket.emit('chat_message', {
          user: user,
          message: message
        });
        input.value = '';
      }
    }

    function toggleChat() {
      const chatBox = document.getElementById('floating-chat');
      const toggleBtn = document.getElementById('chat-toggle');
      
      chatBox.classList.toggle('minimized');
      toggleBtn.textContent = chatBox.classList.contains('minimized') ? '+' : '−';
    }

    // Handle socket errors
    socket.on('error', function(error) {
      console.error('Socket error received:', error);
      
      // Show user-friendly error message
      if (error.message) {
        // Create a non-intrusive error notification
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #e74c3c;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          z-index: 1001;
          max-width: 300px;
          box-shadow: 0 4px 8px rgba(0,0,0,0.3);
          font-weight: bold;
        `;
        errorDiv.innerHTML = `
          ⚠️ ${error.message}
          <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 16px; cursor: pointer; margin-left: 10px;">×</button>
        `;
        document.body.appendChild(errorDiv);
        
        // Auto-remove after 8 seconds
        setTimeout(() => {
          if (errorDiv.parentElement) {
            errorDiv.remove();
          }
        }, 8000);
      }
      
      // If authentication error, fetch session info for debugging
      if (error.message && error.message.includes('Authentication')) {
        fetch('/session-info')
          .then(response => response.json())
          .then(sessionData => {
            console.log('Session data after auth error:', sessionData);
          })
          .catch(err => console.error('Failed to fetch session info after error:', err));
      }
    });

    function playTrack() {
      // TODO: Implement Spotify Web Playback SDK integration
      // This will require:
      // 1. Loading the Spotify Web Playback SDK
      // 2. Authenticating with Spotify Premium
      // 3. Creating a Web Playback instance
      // 4. Playing the first track in queue
      alert('Spotify Web Playback SDK integration coming soon!\n\nThis will require:\n- Spotify Premium account\n- Web Playback SDK setup\n- Device authorization');
    }

    function updateQueueDisplay() {
      const queueEmpty = document.getElementById("queue-empty");
      const clearBtn = document.getElementById("clear-queue-btn");
      
      if (queueCount === 0) {
        queueEmpty.style.display = "block";
        clearBtn.style.display = "none";
      } else {
        queueEmpty.style.display = "none";
        clearBtn.style.display = "inline-block";
      }
    }

    function reorderQueueByVotes() {
      const queueContainer = document.getElementById("queue");
      const queueItems = Array.from(queueContainer.children);
      
      // Store original positions
      const originalPositions = new Map();
      queueItems.forEach((item, index) => {
        const trackUri = item.getAttribute('data-track-uri');
        originalPositions.set(trackUri, index);
      });
      
      // Sort queue items by vote score (up votes - down votes), then by timestamp
      queueItems.sort((a, b) => {
        const trackUriA = a.getAttribute('data-track-uri');
        const trackUriB = b.getAttribute('data-track-uri');
        
        const votesA = voteData[trackUriA] || { up: 0, down: 0 };
        const votesB = voteData[trackUriB] || { up: 0, down: 0 };
        
        const scoreA = votesA.up - votesA.down;
        const scoreB = votesB.up - votesB.down;
        
        // Sort by score (descending), then by timestamp (ascending) for tie-breaking
        if (scoreB !== scoreA) {
          return scoreB - scoreA; // Higher score first
        }
        
        // If scores are equal, maintain original order (timestamp)
        const timestampA = a.getAttribute('data-timestamp') || 0;
        const timestampB = b.getAttribute('data-timestamp') || 0;
        return timestampA - timestampB;
      });
      
      // Calculate new positions and determine movement direction
      const movements = new Map();
      queueItems.forEach((item, newIndex) => {
        const trackUri = item.getAttribute('data-track-uri');
        const oldIndex = originalPositions.get(trackUri);
        
        if (oldIndex !== newIndex) {
          if (newIndex < oldIndex) {
            movements.set(trackUri, 'up');
          } else {
            movements.set(trackUri, 'down');
          }
        }
      });
      
      // Apply movement animations before reordering
      queueItems.forEach((item) => {
        const trackUri = item.getAttribute('data-track-uri');
        const movement = movements.get(trackUri);
        
        // Remove any existing animation classes
        item.classList.remove('moving-up', 'moving-down', 'highlight-new-vote');
        
        if (movement === 'up') {
          item.classList.add('moving-up');
        } else if (movement === 'down') {
          item.classList.add('moving-down');
        }
      });
      
      // Wait a brief moment for animations to start, then reorder
      setTimeout(() => {
        // Clear the queue container and re-append in new order
        queueContainer.innerHTML = '';
        queueItems.forEach((item, index) => {
          // Add class name for styling
          item.className = 'queue-item';
          
          // Add position indicator
          const positionIndicator = item.querySelector('.position-indicator');
          if (positionIndicator) {
            positionIndicator.textContent = `#${index + 1}`;
          } else {
            // Create position indicator if it doesn't exist
            const indicator = document.createElement('span');
            indicator.className = 'position-indicator';
            indicator.style.cssText = 'position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; font-weight: bold;';
            indicator.textContent = `#${index + 1}`;
            item.style.position = 'relative';
            item.appendChild(indicator);
          }
          
          // Highlight the first track (next to play)
          if (index === 0) {
            item.classList.add('next-to-play');
          } else {
            item.classList.remove('next-to-play');
          }
          
          // Re-apply movement animations if they were active
          const trackUri = item.getAttribute('data-track-uri');
          const movement = movements.get(trackUri);
          if (movement === 'up') {
            item.classList.add('moving-up');
          } else if (movement === 'down') {
            item.classList.add('moving-down');
          }
          
          queueContainer.appendChild(item);
        });
        
        // Clean up animation classes after animation completes
        setTimeout(() => {
          queueItems.forEach((item) => {
            item.classList.remove('moving-up', 'moving-down');
          });
        }, 600);
        
      }, 50);
      
      console.log('Queue reordered by votes with animations');
    }

    async function clearQueue() {
      if (confirm('Are you sure you want to clear the entire queue?')) {
        try {
          const response = await fetch('/queue/clear', { 
            method: 'POST',
            credentials: 'include',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          if (response.ok) {
            // The socket event will handle UI update
            console.log('Queue cleared successfully');
          } else {
            const errorText = await response.text();
            console.error('Failed to clear queue:', response.status, errorText);
            if (response.status === 403) {
              alert('Only hosts can clear the queue. Please make sure you are logged in as a host.');
            } else {
              alert('Failed to clear queue: ' + response.status);
            }
          }
        } catch (err) {
          console.error('Error clearing queue:', err);
          alert('Error clearing queue: ' + err.message);
        }
      }
    }

    async function loadPlaylists() {
      try {
        console.log('loadPlaylists called - User role:', window.userRole);
        
        // Show loading indicator
        const playlistList = document.getElementById('playlist-list');
        playlistList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;"><div class="loading-spinner"></div> Loading playlists...</div>';
        
        console.log('Fetching playlists from /playlists/');
        const res = await fetch('/playlists/', {
          credentials: 'include'
        });
        
        console.log('Playlists response status:', res.status, 'redirected:', res.redirected);
        
        if (res.redirected) {
          console.log('Response was redirected, showing login');
          document.getElementById('login').style.display = 'block';
          return;
        }
        
        const data = await res.json();
        console.log('Playlists data received:', data);
        
        document.getElementById('login').style.display = 'none';
        document.getElementById('playlists').style.display = 'block';
        
        // Update the playlist section title based on user role
        const playlistsTitle = document.querySelector('#playlists h2');
        if (data.is_listener) {
          playlistsTitle.textContent = '🎵 Host\'s Playlists';
        } else if (data.is_host) {
          playlistsTitle.textContent = 'Your Playlists';
        } else {
          playlistsTitle.textContent = 'Playlists';
        }
        
        const ul = document.getElementById('playlist-list');
        ul.innerHTML = ''; // Clear loading indicator
        
        console.log('Processing playlists - Total items:', data.items.length, 'Is listener:', data.is_listener, 'Is host:', data.is_host);
        
        // Visual confirmation that we're processing playlists
        console.log('About to update playlist list element with', data.items.length, 'items');
        
        // Show message if listener and no playlists
        if (data.is_listener && data.items.length === 0) {
          const messageDiv = document.createElement('div');
          messageDiv.style.cssText = `
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
            border: 2px dashed #444;
            border-radius: 8px;
            margin: 20px 0;
          `;
          messageDiv.innerHTML = `
            <div style="font-size: 2em; margin-bottom: 10px;">🎵</div>
            ${data.message || 'No playlists shared yet'}<br><br>
            <small>When a host connects and browses their playlists, they'll appear here for you to explore!</small>
          `;
          ul.appendChild(messageDiv);
          return;
        }
        
        console.log('About to render playlists...');
        data.items.forEach(pl => {
          console.log('Rendering playlist:', pl.name, 'ID:', pl.id, 'Tracks:', pl.tracks ? pl.tracks.total : 'Unknown');
          const li = document.createElement('li');
          li.innerHTML = `
            <span>${pl.name}</span>
            <small>${pl.tracks ? pl.tracks.total : 'Unknown'} tracks</small>
            ${data.is_listener ? '<small style="color: #9C27B0;">👤 Host\'s Playlist</small>' : ''}
          `;
          li.onclick = () => loadPlaylistTracks(pl.id);
          ul.appendChild(li);
        });
        console.log('Finished rendering', data.items.length, 'playlists');
        
        // Add listener mode info message
        if (data.is_listener && data.items.length > 0) {
          const infoDiv = document.createElement('div');
          infoDiv.style.cssText = `
            background: rgba(156, 39, 176, 0.1);
            padding: 10px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 0.85em;
            color: #ccc;
            text-align: center;
          `;
          infoDiv.innerHTML = '💡 These are playlists shared by the current host. Click to explore!';
          ul.appendChild(infoDiv);
        }
        
      } catch (err) {
        console.error('Error loading playlists:', err);
        
        // Show error message with more details
        const ul = document.getElementById('playlist-list');
        ul.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #e74c3c;">
            <div style="font-size: 2em; margin-bottom: 10px;">❌</div>
            Error loading playlists<br>
            <small style="color: #999; margin-top: 10px; display: block;">
              Error: ${err.message}<br>
              User Role: ${window.userRole}<br>
              Time: ${new Date().toLocaleTimeString()}
            </small>
            <button onclick="loadPlaylists()" style="
              margin-top: 10px; 
              padding: 5px 10px; 
              background: #1db954; 
              color: white; 
              border: none; 
              border-radius: 3px; 
              cursor: pointer;
            ">Try Again</button>
          </div>
        `;
      }
    }

    function queueTrack(trackUri, trackName) {
      console.log('queueTrack called with:', { trackUri, trackName });
      console.log('Socket connected:', socketConnected);
      console.log('User role:', window.userRole);
      
      if (!socketConnected) {
        console.error('Socket not connected');
        alert('Connection issue. Please refresh the page.');
        return;
      }
      
      // Allow both hosts and listeners to add tracks to the queue
      if (window.userRole !== 'host' && window.userRole !== 'listener') {
        alert('You must be a host or listener to add tracks to the queue.');
        return;
      }
      
      // Debug session info before attempting to queue
      fetch('/session-info', {
        credentials: 'include'
      })
               .then(response => response.json())
        .then(sessionData => {
          console.log('Current session data:', sessionData);
        })
        .catch(err => console.error('Failed to fetch session info:', err));
      
      socket.emit('queue_add', { 
        track_uri: trackUri,
        track_name: trackName
      });
      
      console.log('Emitted queue_add event');
    }

    async function loadPlaylistTracks(playlistId) {
      try {
        // Show loading indicator
        document.getElementById('playlists').style.display = 'none';
        document.getElementById('tracks').style.display = 'block';
        
        const trackList = document.getElementById('track-list');
        trackList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;"><div class="loading-spinner"></div> Loading tracks...</div>';
        
        const res = await fetch(`/playlists/${playlistId}/tracks`, {
          credentials: 'include'
        });
        if (res.redirected) {
          window.location = res.url;
          return;
        }
        const data = await res.json();
        
        // Update tracks section title
        const tracksTitle = document.querySelector('#tracks h2');
        if (data.guest_mode) {
          tracksTitle.textContent = '🎵 Playlist Tracks (Guest View)';
        } else {
          tracksTitle.textContent = 'Playlist Tracks';
        }
        
        const ul = document.getElementById('track-list');
        ul.innerHTML = ''; // Clear loading indicator

        // Handle guest mode with no tracks
        if (data.guest_mode && data.items.length === 0) {
          const messageDiv = document.createElement('div');
          messageDiv.style.cssText = `
            text-align: center;
            padding: 30px 20px;
            color: #666;
            border: 2px dashed #444;
            border-radius: 8px;
            margin: 20px 0;
          `;
          messageDiv.innerHTML = `
            <div style="font-size: 2.5em; margin-bottom: 15px;">🎵</div>
            <strong>${data.message || 'No tracks cached yet'}</strong><br><br>
            <small style="color: #999;">
              The host needs to browse this playlist first to cache the tracks for guests.<br>
              You can still vote on tracks that are already in the queue!
            </small><br><br>
            <button onclick="loadPlaylists()" style="
              background: linear-gradient(135deg, #9C27B0, #E91E63);
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              margin-top: 10px;
            ">← Back to Playlists</button>
          `;
          ul.appendChild(messageDiv);
          return;
        }

        // Display tracks
        data.items.forEach(item => {
          const t = item.track;
          if (t && t.name) { // Check if track exists (some tracks can be null)
            const li = document.createElement('li');
            li.innerHTML = `
              <div>
                <strong>${t.name}</strong><br>
                <small>${t.artists.map(a => a.name).join(', ')}</small>
                ${data.guest_mode ? '<small style="color: #9C27B0; font-size: 0.7em;">👤 Cached for guests</small>' : ''}
              </div>
            `;
            const btn = document.createElement('button');
            
            // Show appropriate button based on role
            if (window.userRole === 'host') {
              btn.textContent = 'Add to Queue';
              btn.onclick = () => queueTrack(t.uri, `${t.name} - ${t.artists.map(a => a.name).join(', ')}`);
              li.appendChild(btn);
            } else if (window.userRole === 'listener') {
              btn.disabled = true;
              btn.textContent = 'Host Only';
              btn.style.opacity = '0.5';
              btn.title = 'Only the host can add tracks to the queue';
              li.appendChild(btn);
            } else {
              // Guests get a different message
              const guestMsg = document.createElement('small');
              guestMsg.style.cssText = 'color: #9C27B0; font-style: italic; margin-left: 10px;';
              guestMsg.textContent = '(Vote on queued tracks instead!)';
              li.appendChild(guestMsg);
            }
            
            ul.appendChild(li);
          }
        });
        
        // Add info for guest mode
        if (data.guest_mode && data.items.length > 0) {
          const infoDiv = document.createElement('div');
          infoDiv.style.cssText = `
            background: rgba(156, 39, 176, 0.1);
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 0.85em;
            color: #ccc;
            text-align: center;
          `;
          infoDiv.innerHTML = `
            💡 <strong>Guest Mode:</strong> You can see tracks but can't add them to the queue.<br>
            Head to the queue section to vote on tracks that are already queued!
          `;
          ul.appendChild(infoDiv);
        }
        
      } catch (err) {
        console.error('Error loading playlist tracks:', err);
        const ul = document.getElementById('track-list');
        ul.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #e74c3c;">
            <div style="font-size: 2em; margin-bottom: 10px;">❌</div>
            Error loading tracks. Please try again later.
          </div>
        `;
      }
    }

    window.onload = function() {
      // Immediately hide login div if user is authenticated
      if (window.userRole && (window.userRole === 'host' || window.userRole === 'listener')) {
        const loginDiv = document.getElementById('login');
        if (loginDiv) {
          console.log('Immediately hiding login div for authenticated user:', window.userRole);
          loginDiv.style.display = 'none';
          loginDiv.style.visibility = 'hidden';
          loginDiv.style.height = '0px';
          loginDiv.style.overflow = 'hidden';
        }
        
        const roleSelection = document.querySelector('.role-selection');
        if (roleSelection) {
          roleSelection.style.display = 'none';
        }
      }
      
      // Load playlists for hosts and listeners (listeners see host's playlists)
      if (window.userRole === 'host' || window.userRole === 'listener') {
        loadPlaylists();
      }
      loadInitialQueue();
      
      // Initialize role-based UI
      console.log('Page loaded, initializing role-based UI...');
      initializeRoleBasedUI();
      
      // Fetch user profile if logged in (not guest or listener without Spotify)
      if (window.userRole === 'host') {
        fetchUserProfile();
      }
      
      document.getElementById('back-btn').onclick = function() {
        document.getElementById('tracks').style.display = 'none';
        document.getElementById('playlists').style.display = 'block';
        // clear track list
        document.getElementById('track-list').innerHTML = '';
      };
    };

    async function loadInitialQueue() {
      try {
        const response = await fetch('/queue');
        const data = await response.json();
        queueCount = data.count;
        updateQueueDisplay();
      } catch (err) {
        console.error('Error loading initial queue:', err);
      }
    }

    // Load recommendations for a track
    async function loadRecs(trackUri, safeTrackId) {
      const recsContainer = document.getElementById(`recs-${safeTrackId}`);
      const btn = event.target;
      
      // Toggle visibility if already loaded
      if (recsContainer.classList.contains('visible')) {
        recsContainer.classList.remove('visible');
        btn.textContent = 'See Similar Tracks';
        return;
      }
      
      // Show loading state
      btn.textContent = 'Loading...';
      btn.disabled = true;
      
      try {
        const response = await fetch(`/recommend/${encodeURIComponent(trackUri)}`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        const recommendations = data.recommendations || [];
        
        if (recommendations.length === 0) {
          const message = data.message || 'No similar tracks found.';
          recsContainer.innerHTML = `<div class="recommendation-item" style="color: #666; font-style: italic;">${message}</div>`;
        } else {
          recsContainer.innerHTML = recommendations.map(rec => `
            <div class="recommendation-item">
              <a href="${rec.url}" target="_blank" class="recommendation-link">
                <strong>${rec.artist}</strong> — ${rec.title}
              </a>
              ${rec.source ? `<small style="color: #666; margin-left: 10px; font-size: 10px;">(${rec.source})</small>` : ''}
            </div>
          `).join('');
        }
        
        recsContainer.classList.add('visible');
        btn.textContent = 'Hide Similar Tracks';
        
      } catch (error) {
        console.error('Error loading recommendations:', error);
        recsContainer.innerHTML = '<div class="recommendation-item" style="color: #e74c3c;">Error loading recommendations. Please try again.</div>';
        recsContainer.classList.add('visible');
        btn.textContent = 'See Similar Tracks';
      } finally {
        btn.disabled = false;
      }
    }

    // Role-based UI initialization
    function initializeRoleBasedUI() {
      const role = window.userRole || 'guest';
      console.log('Initializing UI for role:', role);
      
      // Update UI based on role
      if (role === 'guest') {
        // Show guest-friendly UI
        console.log('Setting up guest UI - can vote and chat');
        
        // Hide login section for guests (they can participate without auth)
        const loginDiv = document.getElementById('login');
        if (loginDiv) {
          loginDiv.style.display = 'none';
        }
        
        // Show all interactive features for guests
        document.getElementById('queue-section').style.display = 'block';
        document.getElementById('floating-chat').style.display = 'block';
        
        // Hide host-only controls for guests
        const clearQueueBtn = document.getElementById('clear-queue-btn');
        if (clearQueueBtn) {
          clearQueueBtn.style.display = 'none';
        }
        
        // Hide restart button for guests
        const restartBtn = document.getElementById('host-restart-btn');
        if (restartBtn) {
          restartBtn.style.display = 'none';
        }
        
        // Hide playback controls for guests (they can only view what's playing)
        const playbackControls = document.getElementById('playback-controls');
        if (playbackControls) {
          playbackControls.style.display = 'none';
        }
        
        const volumeControl = document.getElementById('volume-control');
        if (volumeControl) {
          volumeControl.style.display = 'none';
        }
        
        // Show role indicator for guests
        addRoleIndicator('guest');
        
        // Add guest welcome message
        addGuestWelcomeMessage();
        
      } else if (role === 'listener') {
        // Hide host-only controls for listeners
        const clearQueueBtn = document.getElementById('clear-queue-btn');
        if (clearQueueBtn) {
          clearQueueBtn.style.display = 'none';
        }
        
        // Hide restart button for listeners
        const restartBtn = document.getElementById('host-restart-btn');
        if (restartBtn) {
          restartBtn.style.display = 'none';
        }
        
        // Hide playback controls for listeners (they can only view what's playing)
        const playbackControls = document.getElementById('playback-controls');
        if (playbackControls) {
          playbackControls.style.display = 'none';
        }
        
        const volumeControl = document.getElementById('volume-control');
        if (volumeControl) {
          volumeControl.style.display = 'none';
        }
        
        // Update playback section title to indicate view-only
        const playbackTitle = document.querySelector('#playback-section h3');
        if (playbackTitle) {
          playbackTitle.textContent = '🎵 Now Playing (View Only)';
        }
        
        // Hide login section for listeners
        const loginDiv = document.getElementById('login');
        if (loginDiv) {
          console.log('Hiding login div for listener');
          loginDiv.style.display = 'none';
          loginDiv.style.visibility = 'hidden';
          loginDiv.style.height = '0px';
          loginDiv.style.overflow = 'hidden';
        }
        
        // Also hide any role selection elements
        const roleSelection = document.querySelector('.role-selection');
        if (roleSelection) {
          console.log('Hiding role selection for listener');
          roleSelection.style.display = 'none';
        }
        
        // Show role indicator
        addRoleIndicator('listener');
      } else if (role === 'host') {
        // Show all controls for hosts
        console.log('Setting up host UI - restart button should be visible');
        
        // Force hide login/role selection for authenticated hosts
        const loginDiv = document.getElementById('login');
        if (loginDiv) {
          console.log('Hiding login div for host');
          loginDiv.style.display = 'none';
          loginDiv.style.visibility = 'hidden';
          loginDiv.style.height = '0px';
          loginDiv.style.overflow = 'hidden';
        }
        
        // Also hide any other login-related elements that might be causing gaps
        const roleSelection = document.querySelector('.role-selection');
        if (roleSelection) {
          console.log('Hiding role selection for host');
          roleSelection.style.display = 'none';
        }
        
        // Ensure restart button is visible for hosts
        const restartBtn = document.getElementById('host-restart-btn');
        if (restartBtn) {
          console.log('Restart button found, ensuring visibility');
          restartBtn.style.display = 'inline-block';
          restartBtn.style.visibility = 'visible';
        } else {
          console.error('Restart button not found!');
        }
        
        // Show role indicator
        addRoleIndicator('host');
      }
    }

    function addRoleIndicator(role) {
      const h1 = document.querySelector('h1');
      if (h1 && !document.querySelector('.role-indicator')) {
        const roleSpan = document.createElement('span');
        roleSpan.className = 'role-indicator';
        roleSpan.style.cssText = 'font-size: 0.6em; background: #1db954; color: white; padding: 4px 8px; border-radius: 12px; margin-left: 10px;';
        roleSpan.textContent = role.toUpperCase();
        h1.appendChild(roleSpan);
        
        // Always show a container for user info and logout button
        const userContainer = document.createElement('div');
        userContainer.style.cssText = 'font-size: 0.7em; color: #666; margin-top: 5px; display: flex; align-items: center; gap: 10px;';
        
        // Show display name if available, otherwise show generic welcome
        if (window.displayName && window.displayName !== 'Guest') {
          const nameSpan = document.createElement('span');
          nameSpan.textContent = `Welcome, ${window.displayName}!`;
          userContainer.appendChild(nameSpan);
        } else if (role === 'guest') {
          const nameSpan = document.createElement('span');
          nameSpan.textContent = 'Welcome, Guest!';
          userContainer.appendChild(nameSpan);
        }
        
        // Add logout/role switch button for all roles
        if (role === 'host') {
          const signOutBtn = document.createElement('button');
          signOutBtn.textContent = '🚪 Sign Out as Host';
          signOutBtn.style.cssText = `
            font-size: 1em; 
            background: #e74c3c; 
            color: white; 
            border: none; 
            padding: 8px 12px; 
            border-radius: 4px; 
            cursor: pointer;
            transition: background-color 0.3s;
          `;
          signOutBtn.onmouseover = () => signOutBtn.style.backgroundColor = '#c0392b';
          signOutBtn.onmouseout = () => signOutBtn.style.backgroundColor = '#e74c3c';
          signOutBtn.onclick = signOutAsHost;
          userContainer.appendChild(signOutBtn);
        } else {
          // Add logout/role switch button for listeners and guests
          const switchBtn = document.createElement('button');
          switchBtn.textContent = role === 'guest' ? '🔑 Login or Switch Role' : '🔄 Switch Role';
          switchBtn.style.cssText = `
            font-size: 1em; 
            background: #1db954; 
            color: white; 
            border: none; 
            padding: 8px 12px; 
            border-radius: 4px; 
            cursor: pointer;
            transition: background-color 0.3s;
          `;
          switchBtn.onmouseover = () => switchBtn.style.backgroundColor = '#1ed760';
          switchBtn.onmouseout = () => switchBtn.style.backgroundColor = '#1db954';
          switchBtn.onclick = () => {
            window.location.href = '/logout';
          };
          userContainer.appendChild(switchBtn);
        }
        
        h1.appendChild(userContainer);
      }
    }

    function addGuestWelcomeMessage() {
      const h1 = document.querySelector('h1');
      if (h1 && !document.querySelector('.guest-welcome')) {
        const welcomeDiv = document.createElement('div');
        welcomeDiv.className = 'guest-welcome';
        welcomeDiv.style.cssText = `
          background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(233, 30, 99, 0.1));
          padding: 20px;
          border-radius: 12px;
          margin: 20px 0;
          border: 1px solid rgba(156, 39, 176, 0.3);
          font-size: 0.95em;
          color: white;
          box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        `;
        welcomeDiv.innerHTML = `
          <div style="text-align: center;">
            <strong style="font-size: 1.1em;">👋 Welcome, Guest!</strong><br><br>
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 15px; margin: 15px 0;">
              <div style="flex: 1; min-width: 120px; text-align: center;">
                <div style="font-size: 1.5em; margin-bottom: 5px;">🗳️</div>
                <strong>Vote on Tracks</strong><br>
                <small style="color: #ccc;">Help decide what plays next</small>
              </div>
              <div style="flex: 1; min-width: 120px; text-align: center;">
                <div style="font-size: 1.5em; margin-bottom: 5px;">💬</div>
                <strong>Join the Chat</strong><br>
                <small style="color: #ccc;">Talk with other listeners</small>
              </div>
              <div style="flex: 1; min-width: 120px; text-align: center;">
                <div style="font-size: 1.5em; margin-bottom: 5px;">🎵</div>
                <strong>Browse Playlists</strong><br>
                <small style="color: #ccc;">See what's available</small>
              </div>
            </div>
            <small style="color: #ccc; font-style: italic;">
              No sign-up required! To host your own session, <a href="javascript:void(0)" onclick="location.reload()" style="color: #E91E63; text-decoration: underline;">click here</a> to go back.
            </small>
          </div>
        `;
        
        // Insert after the h1
        h1.parentNode.insertBefore(welcomeDiv, h1.nextSibling);
      }
    }

    // Sign out as host function
    async function signOutAsHost() {
      if (confirm('Are you sure you want to sign out as host? This will end the session for everyone.')) {
        try {
          const response = await fetch('/sign-out-host', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          
          if (response.ok) {
            alert('You have been signed out as host. Redirecting to role selection...');
            window.location.href = '/select-role';
          } else {
            alert('Error signing out. Please try again.');
          }
        } catch (error) {
          console.error('Error signing out:', error);
          alert('Error signing out. Please try again.');
        }
      }
    }

    // Debug function to check player state
    async function debugPlayerState() {
      console.log('=== SPOTIFY PLAYER DEBUG ===');
      console.log('Access Token:', accessToken ? 'Present' : 'Missing');
      console.log('Device ID:', deviceId || 'Missing');
      console.log('Player Object:', player ? 'Present' : 'Missing');
      
      if (player) {
        try {
          const state = await player.getCurrentState();
          console.log('Player State:', state);
        } catch (error) {
          console.log('Error getting player state:', error);
        }
      }
      
      // Check available devices
      try {
        const response = await fetch('/playback/devices');
        const devices = await response.json();
        console.log('Available Devices:', devices);
      } catch (error) {
        console.log('Error getting devices:', error);
      }
      
      console.log('=== END DEBUG ===');
    }

    // Add debug button to console (for development)
    window.debugPlayer = debugPlayerState;

    // Fetch user profile function
    async function fetchUserProfile() {
      try {
        console.log('Fetching user profile to update display name...');
        const response = await fetch('/fetch-user-profile', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const data = await response.json();
          console.log('User profile fetched:', data);
          
          // Update global variables
          window.userId = data.user_id;
          window.displayName = data.display_name;
          
          // Update the role indicator with the real name
          updateUserDisplayName(data.display_name);
          
          // Only reload playlists for hosts (listeners get host's playlists automatically)
          if (window.userRole === 'host') {
            console.log('Reloading playlists with updated user profile...');
            loadPlaylists();
          }
          
        } else {
          const error = await response.json();
          console.warn('Could not fetch user profile:', error.error);
        }
      } catch (error) {
        console.error('Error fetching user profile:', error);
      }
    }

    // Update user display name in the UI
    function updateUserDisplayName(displayName) {
      // Find and update the welcome message in the role indicator
      const userContainer = document.querySelector('.role-indicator').nextElementSibling;
      if (userContainer) {
        const nameSpan = userContainer.querySelector('span');
        if (nameSpan && nameSpan.textContent.startsWith('Welcome,')) {
          nameSpan.textContent = `Welcome, ${displayName}!`;
          console.log('Updated display name to:', displayName);
        }
      }
    }

    // Transfer playback to the Web Playback SDK device
  </script>
</body>
</html>
